// ta_Dump File v3.0 -- code v8.5.6.0 rev11491
LeabraProject .projects[0] { 
 Doc_Group @.docs = [2] {
  taDoc @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };
  };
  taDoc @[1] { };
 };

 Wizard_Group @.wizards = [1] {
  LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };
  };
 };

 ControlPanel_Group @.ctrl_panels = [2] {
  ControlPanel @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @[0] { };
    UserDataItem @[1] { };
   };

   ControlPanelMember_Group @.mbrs = [6] {
    ControlPanelMember @[0] { };
    ControlPanelMember @[1] { };
    ControlPanelMember @[2] { };
    ControlPanelMember @[3] { };
    ControlPanelMember @[4] { };
    ControlPanelMember @[5] { };
   };

   ControlPanelMethod_Group @.mths = [10] {
    ControlPanelMethod @[0] { };
    ControlPanelMethod @[1] { };
    ControlPanelMethod @[2] { };
    ControlPanelMethod @[3] { };
    ControlPanelMethod @[4] { };
    ControlPanelMethod @[5] { };
    ControlPanelMethod @[6] { };
    ControlPanelMethod @[7] { };
    ControlPanelMethod @[8] { };
    ControlPanelMethod @[9] { };
   };
  };
  ClusterRun @[1] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };

   ControlPanelMember_Group @.mbrs = [21] {
    ControlPanelMember @[0] { };
    ControlPanelMember @[1] { };
    ControlPanelMember @[2] { };
    ControlPanelMember @[3] { };
    ControlPanelMember @[4] { };
    ControlPanelMember @[5] { };
    ControlPanelMember @[6] { };
    ControlPanelMember @[7] { };
    ControlPanelMember @[8] { };
    ControlPanelMember @[9] { };
    ControlPanelMember @[10] { };
    ControlPanelMember @[11] { };
    ControlPanelMember @[12] { };
    ControlPanelMember @[13] { };
    ControlPanelMember @[14] { };
    ControlPanelMember @[15] { };
    ControlPanelMember @[16] { };
    ControlPanelMember @[17] { };
    ControlPanelMember @[18] { };
    ControlPanelMember @[19] { };
    ControlPanelMember @[20] { };
   };

   ControlPanelMethod_Group @.mths = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
 };

 ParamSet_Group @.active_params = [0] {
 };

 ArchivedParams_Group @.archived_params = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp[0] = [4] { 
   DataTable @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserDataItem @[0] { };
    };

    DataTableCols @.data = [4] {
     String_Data @[0] { };
     String_Data @[1] { };
     float_Data @[2] { };
     float_Data @[3] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [4] {
     String_Data @[0] { };
     String_Data @[1] { };
     float_Data @[2] { };
     float_Data @[3] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[2] { 
    DataTableCols @.data = [2] {
     String_Data @[0] { };
     float_Data @[1] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserDataItem @[0] { };
     UserDataItem @[1] { };
     UserDataItem @[2] { };
    };

    DataTableCols @.data = [3] {
     String_Data @[0] { };
     String_Data @[1] { };
     String_Data @[2] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[1] = [4] { 
   DataTable @[0] { 
    DataTableCols @.data = [11] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[4] { };
     String_Data @[5] { };
     int_Data @[6] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     float_Data @[7] { };
     float_Data @[8] { };
     float_Data @[9] { };
     float_Data @[10] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [12] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[3] { };
     String_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
     float_Data @[9] { };
     float_Data @[10] { };
     float_Data @[11] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[2] { 
    DataTableCols @.data = [9] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[3] { 
    DataTableCols @.data = [9] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[2] { 
  };
  DataTable_Group @.gp[3] { 
  };
 };

 Program_TopGroup @.programs = [2] {
  Program @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @[0] { };
   };

   ProgObjList @.objs = [0] {
   };

   ProgVar_List @.objs_vars = [0] {
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [2] {
    ProgVar @[0] { };
    ProgVar @[1] { };
   };

   ProgVar_List @.vars = [12] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
    ProgVar @[5] { };
    ProgVar @[6] { };
    ProgVar @[7] { };
    ProgVar @[8] { };
    ProgVar @[9] { };
    ProgVar @[10] { };
    ProgVar @[11] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [31] {
    ReturnExpr @[0] { };
    RegisterArgs @[1] { };
    PrintExpr @[2] { };
    Comment @[3] { };
    ProgVarFmArg @[4] { };
    ProgVarFmArg @[5] { };
    ProgVarFmArg @[6] { };
    ProgVarFmArg @[7] { };
    ProgVarFmArg @[8] { };
    ProgVarFmArg @[9] { };
    ProgVarFmArg @[10] { };
    ProgVarFmArg @[11] { };
    ProgVarFmArg @[12] { };
    ControlPanelsFmArgs @[13] { };
    If @[14] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    Comment @[15] { };
    Comment @[16] { };
    If @[17] { 
     ProgEl_List @.true_code = [4] {
      ProgVarFmArg @[0] { };
      MiscCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      VarIncr @[2] { };
      If @[3] { 
       ProgEl_List @.true_code = [2] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [4] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	  ProgArg @[3] { };
	 };
	};
	MiscCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
    Else @[18] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MiscCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    MiscCall @[19] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    Comment @[20] { };
    MethodCall @[21] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[22] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[23] { };
    Comment @[24] { };
    MethodCall @[25] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[26] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[27] { };
    OtherProgramVar @[28] { };
    PrintExpr @[29] { };
    ProgramCall @[30] { 
     ProgArg_List @.prog_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
   };
  };
  Program @[1] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @[0] { };
   };

   ProgObjList @.objs = [4] {
    Relation @[0] { };
    DataTable @[1] { 
     DataTableCols @.data = [25] {
      int_Data @[0] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      int_Data @[1] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[2] { };
      float_Data @[3] { };
      float_Data @[4] { };
      float_Data @[5] { };
      float_Data @[6] { };
      float_Data @[7] { };
      float_Data @[8] { };
      String_Data @[9] { };
      String_Data @[10] { };
      String_Data @[11] { };
      String_Data @[12] { };
      String_Data @[13] { };
      String_Data @[14] { };
      float_Data @[15] { };
      float_Data @[16] { };
      float_Data @[17] { };
      float_Data @[18] { };
      float_Data @[19] { };
      float_Data @[20] { };
      float_Data @[21] { };
      float_Data @[22] { };
      float_Data @[23] { };
      float_Data @[24] { };
     };

     DataOpList @.last_sort_spec.ops = [0] {
     };
    };
    DataTable @[2] { 
     DataTableCols @.data = [8] {
      String_Data @[0] { };
      int_Data @[1] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[2] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[3] { };
      float_Data @[4] { };
      String_Data @[5] { };
      String_Data @[6] { };
      String_Data @[7] { };
     };

     DataOpList @.last_sort_spec.ops = [0] {
     };
    };
    DataTable @[3] { 
     DataTableCols @.data = [19] {
      String_Data @[0] { };
      String_Data @[1] { };
      String_Data @[2] { };
      String_Data @[3] { };
      float_Data @[4] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[5] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[6] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[7] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[8] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[9] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
       };
      };
      float_Data @[10] { };
      float_Data @[11] { };
      float_Data @[12] { };
      float_Data @[13] { };
      float_Data @[14] { };
      float_Data @[15] { };
      float_Data @[16] { };
      float_Data @[17] { };
      float_Data @[18] { };
     };

     DataOpList @.last_sort_spec.ops = [0] {
     };
    };
   };

   ProgVar_List @.objs_vars = [0] {
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [0] {
   };

   ProgVar_List @.vars = [8] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
    ProgVar @[5] { };
    ProgVar @[6] { };
    ProgVar @[7] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    ForeachLoop @[2] { 
     ProgEl_List @.loop_code = [2] {
      If @[0] { 
       ProgEl_List @.true_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
      Else @[1] { 
       ProgEl_List @.true_code = [1] {
	DataProcCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
       };
      };
     };
    };
    DataGroupProg @[3] { 
     DataOpList @.group_spec.ops = [8] {
      DataGroupEl @[0] { };
      DataGroupEl @[1] { };
      DataGroupEl @[2] { };
      DataGroupEl @[3] { };
      DataGroupEl @[4] { };
      DataGroupEl @[5] { };
      DataGroupEl @[6] { };
      DataGroupEl @[7] { };
     };
    };
    MemberMethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MathCall @[5] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MathCall @[6] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    DataGroupProg @[7] { 
     DataOpList @.group_spec.ops = [19] {
      DataGroupEl @[0] { };
      DataGroupEl @[1] { };
      DataGroupEl @[2] { };
      DataGroupEl @[3] { };
      DataGroupEl @[4] { };
      DataGroupEl @[5] { };
      DataGroupEl @[6] { };
      DataGroupEl @[7] { };
      DataGroupEl @[8] { };
      DataGroupEl @[9] { };
      DataGroupEl @[10] { };
      DataGroupEl @[11] { };
      DataGroupEl @[12] { };
      DataGroupEl @[13] { };
      DataGroupEl @[14] { };
      DataGroupEl @[15] { };
      DataGroupEl @[16] { };
      DataGroupEl @[17] { };
      DataGroupEl @[18] { };
     };
    };
    MemberAssign @[8] { };
    MemberAssign @[9] { };
   };
  };
  Program_Group @.gp[0] = [10] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [4] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @[0] { };
      };
     };
     AssignExpr @[1] { };
     MemberAssign @[2] { };
     ForLoop @[3] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [3] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	};
       };
       NetCounterIncr @[1] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [2] {
     RndSeed_List @[0] { 
      taList @.seeds = [25] {
       RndSeed @[0] { };
       RndSeed @[1] { };
       RndSeed @[2] { };
       RndSeed @[3] { };
       RndSeed @[4] { };
       RndSeed @[5] { };
       RndSeed @[6] { };
       RndSeed @[7] { };
       RndSeed @[8] { };
       RndSeed @[9] { };
       RndSeed @[10] { };
       RndSeed @[11] { };
       RndSeed @[12] { };
       RndSeed @[13] { };
       RndSeed @[14] { };
       RndSeed @[15] { };
       RndSeed @[16] { };
       RndSeed @[17] { };
       RndSeed @[18] { };
       RndSeed @[19] { };
       RndSeed @[20] { };
       RndSeed @[21] { };
       RndSeed @[22] { };
       RndSeed @[23] { };
       RndSeed @[24] { };
      };
     };
     RndSeed @[1] { };
    };

    ProgVar_List @.objs_vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgType_List @.types = [1] {
     DynEnumType @[0] { 
      DynEnumItem_List @.enums = [3] {
       DynEnumItem @[0] { };
       DynEnumItem @[1] { };
       DynEnumItem @[2] { };
      };
     };
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [10] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
     ProgVar @[9] { };
    };

    Function_List @.functions = [1] {
     Function @[0] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [2] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       Switch @[1] { 
	ProgEl_List @.cases = [3] {
	 CaseBlock @[0] { 
	  ProgEl_List @.prog_code = [1] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	 CaseBlock @[1] { 
	  ProgEl_List @.prog_code = [1] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	 CaseBlock @[2] { 
	  ProgEl_List @.prog_code = [1] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [1] {
	     ProgArg @[0] { };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [8] {
     MemberAssign @[0] { };
     AssignExpr @[1] { };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     AssignExpr @[3] { };
     AssignExpr @[4] { };
     FunctionCall @[5] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     WtInitPrompt @[6] { 
      ProgEl_List @.yes_code = [3] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       PrintExpr @[2] { };
      };
     };
     AssignExpr @[7] { };
    };

    ProgEl_List @.prog_code = [11] {
     MemberAssign @[0] { };
     AssignExpr @[1] { };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     AssignExpr @[3] { };
     MemberAssign @[4] { };
     FunctionCall @[5] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     If @[6] { 
      ProgEl_List @.true_code = [2] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       PrintExpr @[1] { };
      };
     };
     AssignExpr @[7] { };
     WhileLoop @[8] { 
      ProgEl_List @.loop_code = [5] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       NetCounterIncr @[1] { };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 VarIncr @[0] { };
	 IfBreak @[1] { };
	};
       };
       Else @[3] { 
	ProgEl_List @.true_code = [1] {
	 AssignExpr @[0] { };
	};
       };
       If @[4] { 
	ProgEl_List @.true_code = [1] {
	 If @[0] { 
	  ProgEl_List @.true_code = [1] {
	   ProgramCall @[0] { 
	    ProgArg_List @.prog_args = [1] {
	     ProgArg @[0] { };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     If @[9] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[10] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [10] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
     ProgVar @[9] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     NetCounterInit @[0] { };
     AssignExpr @[1] { };
    };

    ProgEl_List @.prog_code = [10] {
     NetCounterInit @[0] { };
     AssignExpr @[1] { };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     NetDataLoop @[5] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 StopStepPoint @[0] { };
	};
       };
      };
     };
     If @[6] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[8] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[9] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [10] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @[0] { };
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     Comment @[3] { };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[5] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ForLoop @[6] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[8] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     NetUpdateView @[9] { };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [11] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [2] {
       ProgVar @[0] { };
       ProgVar @[1] { };
      };
     };
     NetCounterInit @[1] { };
     Comment @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ForLoop @[7] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
       AssignExpr @[1] { };
      };
     };
     MethodCall @[8] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[9] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[10] { };
    };
   };
   Program @[5] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[1] { };
    };
   };
   Program @[6] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [4] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
       LayerWriterEl @[3] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[7] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [11] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
       NetMonItem @[6] { };
       NetMonItem @[7] { };
       NetMonItem @[8] { };
       NetMonItem @[9] { };
       NetMonItem @[10] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [8] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     AssignExpr @[2] { };
     If @[3] { 
      ProgEl_List @.true_code = [1] {
       AssignExpr @[0] { };
      };
     };
     Else @[4] { 
      ProgEl_List @.true_code = [1] {
       ForLoop @[0] { 
	ProgEl_List @.loop_code = [1] {
	 If @[0] { 
	  ProgEl_List @.true_code = [1] {
	   If @[0] { 
	    ProgEl_List @.true_code = [2] {
	     AssignExpr @[0] { };
	     UserScript @[1] { };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     DataVarProg @[5] { };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @[8] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [2] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [9] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
       NetMonItem @[6] { };
       NetMonItem @[7] { };
       NetMonItem @[8] { };
      };
     };
     DataTable @[1] { 
      DataTableCols @.data = [1] {
       float_Data @[0] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgVar_List @.objs_vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [4] {
     AssignExpr @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [10] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     AssignExpr @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     DataGroupProg @[5] { 
      DataOpList @.group_spec.ops = [1] {
       DataGroupEl @[0] { };
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     DataVarProg @[7] { };
     MemberAssign @[8] { };
     MethodCall @[9] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[9] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [6] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ReturnExpr @[0] { };
      };
     };
     MiscCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MiscCall @[2] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     AssignExpr @[3] { };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
  };
  Program_Group @.gp[1] = [8] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [8] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     NetCounterInit @[0] { };
     AssignExpr @[1] { };
    };

    ProgEl_List @.prog_code = [12] {
     NetCounterInit @[0] { };
     MemberAssign @[1] { };
     ProgramCall @[2] { 
      ProgArg_List @.prog_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     AssignExpr @[3] { };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetGroupedDataLoop @[6] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     If @[7] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[8] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[9] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[10] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MemberAssign @[11] { };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [10] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
     ProgVar @[9] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     NetCounterInit @[0] { };
     AssignExpr @[1] { };
    };

    ProgEl_List @.prog_code = [12] {
     MemberAssign @[0] { };
     NetCounterInit @[1] { };
     AssignExpr @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[5] { 
      ProgArg_List @.prog_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     NetDataLoop @[6] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 StopStepPoint @[0] { };
	};
       };
      };
     };
     If @[7] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[8] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[9] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[10] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MemberAssign @[11] { };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [10] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @[0] { };
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     Comment @[3] { };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[5] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ForLoop @[6] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[8] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     NetUpdateView @[9] { };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [11] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [2] {
       ProgVar @[0] { };
       ProgVar @[1] { };
      };
     };
     NetCounterInit @[1] { };
     Comment @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ForLoop @[7] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
       AssignExpr @[1] { };
      };
     };
     MethodCall @[8] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[9] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[10] { };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[1] { };
    };
   };
   Program @[5] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [4] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
       LayerWriterEl @[3] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[6] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [12] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
       NetMonItem @[6] { };
       NetMonItem @[7] { };
       NetMonItem @[8] { };
       NetMonItem @[9] { };
       NetMonItem @[10] { };
       NetMonItem @[11] { };
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [7] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     AssignExpr @[2] { };
     ForLoop @[3] { 
      ProgEl_List @.loop_code = [1] {
       If @[0] { 
	ProgEl_List @.true_code = [1] {
	 If @[0] { 
	  ProgEl_List @.true_code = [2] {
	   AssignExpr @[0] { };
	   UserScript @[1] { };
	  };
	 };
	};
       };
      };
     };
     DataVarProg @[4] { };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @[7] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [2] {
     NetMonitor @[0] { 
      NetMonItem_List @.items = [9] {
       NetMonItem @[0] { };
       NetMonItem @[1] { };
       NetMonItem @[2] { };
       NetMonItem @[3] { };
       NetMonItem @[4] { };
       NetMonItem @[5] { };
       NetMonItem @[6] { };
       NetMonItem @[7] { };
       NetMonItem @[8] { };
      };
     };
     DataTable @[1] { 
      DataTableCols @.data = [1] {
       float_Data @[0] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgVar_List @.objs_vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [4] {
     AssignExpr @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [10] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     AssignExpr @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     DataGroupProg @[5] { 
      DataOpList @.group_spec.ops = [1] {
       DataGroupEl @[0] { };
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     DataVarProg @[7] { };
     MemberAssign @[8] { };
     MethodCall @[9] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
  };
  Program_Group @.gp[2] = [5] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [1] {
     DynEnumType @[0] { 
      DynEnumItem_List @.enums = [2] {
       DynEnumItem @[0] { };
       DynEnumItem @[1] { };
      };
     };
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [5] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ReturnExpr @[0] { };
      };
     };
     ResetDataRows @[1] { };
     ForLoop @[2] { 
      ProgEl_List @.loop_code = [1] {
       Switch @[0] { 
	ProgEl_List @.cases = [2] {
	 CaseBlock @[0] { 
	  ProgEl_List @.prog_code = [1] {
	   ProgramCall @[0] { 
	    ProgArg_List @.prog_args = [2] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	    };
	   };
	  };
	 };
	 CaseBlock @[1] { 
	  ProgEl_List @.prog_code = [1] {
	   ProgramCall @[0] { 
	    ProgArg_List @.prog_args = [2] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     AssignExpr @[3] { };
     PrintVar @[4] { };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [4] {
     DataTable @[0] { 
      DataTableCols @.data = [6] {
       float_Data @[0] { };
       float_Data @[1] { };
       float_Data @[2] { };
       float_Data @[3] { };
       float_Data @[4] { };
       float_Data @[5] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
     DataTable @[1] { 
      DataTableCols @.data = [6] {
       int_Data @[0] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[1] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[2] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[3] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[4] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[5] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
     DataTable @[2] { 
      DataTableCols @.data = [6] {
       int_Data @[0] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[1] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[2] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[3] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[4] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[5] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
     DataTable @[3] { 
      DataTableCols @.data = [6] {
       int_Data @[0] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[1] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[2] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[3] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[4] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[5] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgVar_List @.objs_vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [9] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [5] {
     Comment @[0] { };
     AssignExpr @[1] { };
     ProgramCall @[2] { 
      ProgArg_List @.prog_args = [5] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
       ProgArg @[4] { };
      };
     };
     WhileLoop @[3] { 
      ProgEl_List @.loop_code = [6] {
       AssignExpr @[0] { };
       AssignExpr @[1] { };
       RandomCall @[2] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       ForLoop @[3] { 
	ProgEl_List @.loop_code = [5] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [2] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	  };
	 };
	 If @[1] { 
	  ProgEl_List @.true_code = [3] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	    };
	   };
	   AssignExpr @[1] { };
	   AssignExpr @[2] { };
	  };
	 };
	 Else @[2] { 
	  ProgEl_List @.true_code = [1] {
	   If @[0] { 
	    ProgEl_List @.true_code = [1] {
	     MethodCall @[0] { 
	      ProgArg_List @.meth_args = [2] {
	       ProgArg @[0] { };
	       ProgArg @[1] { };
	      };
	     };
	    };
	   };
	  };
	 };
	 VarIncr @[3] { };
	 PrintExpr @[4] { };
	};
       };
       ProgramCall @[4] { 
	ProgArg_List @.prog_args = [5] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	 ProgArg @[3] { };
	 ProgArg @[4] { };
	};
       };
       AssignExpr @[5] { };
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [5] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
       ProgArg @[4] { };
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [2] {
     DataTable @[0] { 
      DataTableCols @.data = [6] {
       float_Data @[0] { };
       float_Data @[1] { };
       float_Data @[2] { };
       float_Data @[3] { };
       float_Data @[4] { };
       float_Data @[5] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
     DataTable @[1] { 
      DataTableCols @.data = [6] {
       int_Data @[0] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[1] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[2] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[3] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[4] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
       int_Data @[5] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgVar_List @.objs_vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [5] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [5] {
     Comment @[0] { };
     AssignExpr @[1] { };
     AssignExpr @[2] { };
     AssignExpr @[3] { };
     WhileLoop @[4] { 
      ProgEl_List @.loop_code = [3] {
       AssignExpr @[0] { };
       RandomCall @[1] { 
	ProgArg_List @.meth_args = [3] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	};
       };
       ProgramCall @[2] { 
	ProgArg_List @.prog_args = [5] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	 ProgArg @[3] { };
	 ProgArg @[4] { };
	};
       };
      };
     };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     DataTable @[0] { 
      DataTableCols @.data = [1] {
       String_Data @[0] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgVar_List @.objs_vars = [1] {
     ProgVar @[0] { };
    };

    ProgType_List @.types = [1] {
     DynEnumType @[0] { 
      DynEnumItem_List @.enums = [16] {
       DynEnumItem @[0] { };
       DynEnumItem @[1] { };
       DynEnumItem @[2] { };
       DynEnumItem @[3] { };
       DynEnumItem @[4] { };
       DynEnumItem @[5] { };
       DynEnumItem @[6] { };
       DynEnumItem @[7] { };
       DynEnumItem @[8] { };
       DynEnumItem @[9] { };
       DynEnumItem @[10] { };
       DynEnumItem @[11] { };
       DynEnumItem @[12] { };
       DynEnumItem @[13] { };
       DynEnumItem @[14] { };
       DynEnumItem @[15] { };
      };
     };
    };

    ProgVar_List @.args = [5] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
    };

    ProgVar_List @.vars = [5] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     InitNamedUnits @[0] { };
    };

    ProgEl_List @.prog_code = [8] {
     AddNewDataRow @[0] { };
     DataVarProg @[1] { };
     AssignExpr @[2] { };
     CssExpr @[3] { };
     CssExpr @[4] { };
     If @[5] { 
      ProgEl_List @.true_code = [2] {
       DataVarProg @[0] { };
       CssExpr @[1] { };
      };
     };
     AssignExpr @[6] { };
     DataVarProg @[7] { };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [0] {
    };

    ProgVar_List @.vars = [9] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     MemberAssign @[0] { };
     MemberAssign @[1] { };
     MemberAssign @[2] { };
     MemberAssign @[3] { };
     MemberAssign @[4] { };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
  };
  Program_Group @.gp[3] = [1] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     DataTable @[0] { 
      DataTableCols @.data = [3] {
       float_Data @[0] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	 UserDataItem @[1] { };
	};
       };
       float_Data @[1] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	 UserDataItem @[1] { };
	 UserDataItem @[2] { };
	};
       };
       String_Data @[2] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @[0] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgVar_List @.objs_vars = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [0] {
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     DataAnalCall @[0] { 
      ProgArg_List @.meth_args = [8] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
       ProgArg @[4] { };
       ProgArg @[5] { };
       ProgArg @[6] { };
       ProgArg @[7] { };
      };
     };
    };

    ProgEl_List @.prog_code = [0] {
    };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
    UserDataItem @[1] { };
    UserDataItem @[2] { };
    UserDataItem @[3] { };
    UserDataItem @[4] { };
    UserDataItem @[5] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @[0] { };
    PanelViewer @[1] { };
    T3PanelViewer @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };

     T3Panel_List @.panels = [6] {
      T3Panel @[0] { 
       T3DataView_List @.root_view.children = [1] {
	NetView @[0] { 
	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 NetViewStateItem_List @.net_state_text.state_items = [20] {
	  NetViewStateItem @[0] { };
	  NetViewStateItem @[1] { };
	  NetViewStateItem @[2] { };
	  NetViewStateItem @[3] { };
	  NetViewStateItem @[4] { };
	  NetViewStateItem @[5] { };
	  NetViewStateItem @[6] { };
	  NetViewStateItem @[7] { };
	  NetViewStateItem @[8] { };
	  NetViewStateItem @[9] { };
	  NetViewStateItem @[10] { };
	  NetViewStateItem @[11] { };
	  NetViewStateItem @[12] { };
	  NetViewStateItem @[13] { };
	  NetViewStateItem @[14] { };
	  NetViewStateItem @[15] { };
	  NetViewStateItem @[16] { };
	  NetViewStateItem @[17] { };
	  NetViewStateItem @[18] { };
	  NetViewStateItem @[19] { };
	 };

	 ScaleRange_List @.scale_ranges = [41] {
	  ScaleRange @[0] { };
	  ScaleRange @[1] { };
	  ScaleRange @[2] { };
	  ScaleRange @[3] { };
	  ScaleRange @[4] { };
	  ScaleRange @[5] { };
	  ScaleRange @[6] { };
	  ScaleRange @[7] { };
	  ScaleRange @[8] { };
	  ScaleRange @[9] { };
	  ScaleRange @[10] { };
	  ScaleRange @[11] { };
	  ScaleRange @[12] { };
	  ScaleRange @[13] { };
	  ScaleRange @[14] { };
	  ScaleRange @[15] { };
	  ScaleRange @[16] { };
	  ScaleRange @[17] { };
	  ScaleRange @[18] { };
	  ScaleRange @[19] { };
	  ScaleRange @[20] { };
	  ScaleRange @[21] { };
	  ScaleRange @[22] { };
	  ScaleRange @[23] { };
	  ScaleRange @[24] { };
	  ScaleRange @[25] { };
	  ScaleRange @[26] { };
	  ScaleRange @[27] { };
	  ScaleRange @[28] { };
	  ScaleRange @[29] { };
	  ScaleRange @[30] { };
	  ScaleRange @[31] { };
	  ScaleRange @[32] { };
	  ScaleRange @[33] { };
	  ScaleRange @[34] { };
	  ScaleRange @[35] { };
	  ScaleRange @[36] { };
	  ScaleRange @[37] { };
	  ScaleRange @[38] { };
	  ScaleRange @[39] { };
	  ScaleRange @[40] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[1] { 
       T3DataView_List @.root_view.children = [1] {
	GraphTableView @[0] { 
	 T3DataView_List @.children = [9] {
	  GraphColView @[0] { };
	  GraphColView @[1] { };
	  GraphColView @[2] { };
	  GraphColView @[3] { };
	  GraphColView @[4] { };
	  GraphColView @[5] { };
	  GraphColView @[6] { };
	  GraphColView @[7] { };
	  GraphColView @[8] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 GraphPlotView_List @.plots = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };

	 GraphPlotView_List @.errbars = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[2] { 
       T3DataView_List @.root_view.children = [1] {
	GraphTableView @[0] { 
	 T3DataView_List @.children = [11] {
	  GraphColView @[0] { };
	  GraphColView @[1] { };
	  GraphColView @[2] { };
	  GraphColView @[3] { };
	  GraphColView @[4] { };
	  GraphColView @[5] { };
	  GraphColView @[6] { };
	  GraphColView @[7] { };
	  GraphColView @[8] { };
	  GraphColView @[9] { };
	  GraphColView @[10] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 GraphPlotView_List @.plots = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };

	 GraphPlotView_List @.errbars = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[3] { 
       T3DataView_List @.root_view.children = [1] {
	GridTableView @[0] { 
	 T3DataView_List @.children = [12] {
	  GridColView @[0] { };
	  GridColView @[1] { };
	  GridColView @[2] { };
	  GridColView @[3] { };
	  GridColView @[4] { };
	  GridColView @[5] { };
	  GridColView @[6] { };
	  GridColView @[7] { };
	  GridColView @[8] { };
	  GridColView @[9] { };
	  GridColView @[10] { };
	  GridColView @[11] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[4] { 
       T3DataView_List @.root_view.children = [2] {
	GridTableView @[0] { 
	 T3DataView_List @.children = [4] {
	  GridColView @[0] { };
	  GridColView @[1] { };
	  GridColView @[2] { };
	  GridColView @[3] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };
	};
	GridTableView @[1] { 
	 T3DataView_List @.children = [3] {
	  GridColView @[0] { };
	  GridColView @[1] { };
	  GridColView @[2] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[5] { 
       T3DataView_List @.root_view.children = [1] {
	GraphTableView @[0] { 
	 T3DataView_List @.children = [3] {
	  GraphColView @[0] { };
	  GraphColView @[1] { };
	  GraphColView @[2] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 GraphPlotView_List @.plots = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };

	 GraphPlotView_List @.errbars = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
      UserDataItem @[2] { };
      UserDataItem @[3] { };
      UserDataItem @[4] { };
      UserDataItem @[5] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [1] {
  LeabraNetwork @[0] { 
   BaseSpec_Group @.specs = [6] {
    LeabraUnitSpec @[0] { 
     BaseSpec_Group @.children = [3] {
      LeabraUnitSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };
      };
      LeabraUnitSpec @[1] { 
       BaseSpec_Group @.children = [0] {
       };
      };
      LeabraUnitSpec @[2] { 
       BaseSpec_Group @.children = [0] {
       };
      };
     };
    };
    LeabraConSpec @[1] { 
     BaseSpec_Group @.children = [8] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [0] {
       };
      };
      DeepCtxtConSpec @[1] { 
       BaseSpec_Group @.children = [3] {
	DeepCtxtConSpec @[0] { 
	 BaseSpec_Group @.children = [0] {
	 };

	 Schedule @.lrate_sched = [0] {
	 };
	};
	DeepCtxtConSpec @[1] { 
	 BaseSpec_Group @.children = [0] {
	 };

	 Schedule @.lrate_sched = [0] {
	 };
	};
	DeepCtxtConSpec @[2] { 
	 BaseSpec_Group @.children = [0] {
	 };

	 Schedule @.lrate_sched = [0] {
	 };
	};
       };

       Schedule @.lrate_sched = [0] {
       };
      };
      SendDeepRawConSpec @[2] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [0] {
       };
      };
      LeabraConSpec @[3] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [0] {
       };
      };
      LeabraConSpec @[4] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [0] {
       };
      };
      SendDeepModConSpec @[5] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [0] {
       };
      };
      LeabraConSpec @[6] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [0] {
       };
      };
      LeabraConSpec @[7] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [0] {
       };
      };
     };

     Schedule @.lrate_sched = [0] {
     };
    };
    LeabraLayerSpec @[2] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    LeabraLayerSpec @[3] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    FullPrjnSpec @[4] { 
     BaseSpec_Group @.children = [0] {
     };
    };
    OneToOnePrjnSpec @[5] { 
     BaseSpec_Group @.children = [0] {
     };
    };
   };

   ParamSeq_Group @.param_seqs = [0] {
   };

   NetMonItem_List @.monitor.items = [0] {
   };

   DataTableCols @.mon_data.data = [0] {
   };

   DataOpList @.mon_data.last_sort_spec.ops = [0] {
   };

   Layer_Group @.layers = [5] {
    LeabraLayer @[0] { 
     Projection_List @.projections = [0] {
     };
    };
    LeabraLayer @[1] { 
     Projection_List @.projections = [2] {
      LeabraPrjn @[0] { };
      LeabraPrjn @[1] { };
     };
    };
    LeabraLayer @[2] { 
     Projection_List @.projections = [0] {
     };
    };
    LeabraLayer @[3] { 
     Projection_List @.projections = [2] {
      LeabraPrjn @[0] { };
      LeabraPrjn @[1] { };
     };
    };
    LeabraLayer @[4] { 
     Projection_List @.projections = [4] {
      LeabraPrjn @[0] { };
      LeabraPrjn @[1] { };
      LeabraPrjn @[2] { };
      LeabraPrjn @[3] { };
     };
    };
   };

   Weights_List @.weights = [0] {
   };
  };
 };
};
LeabraProject .projects[0] {
 name="fsa_deep_trc";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=5;
 };
 author="Randall C. O'Reilly";
 email="emergent-users@grey.colorado.edu";
 license {
  license=GPLv2;
  owner_name="Regents of the University of Colorado";
  org="CCNLab at the University of Colorado Boulder";
  year="2017";
  custom=;
 };
 pub_cite=;
 wiki {wiki="": page_name="": };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ProjectDocs";
   desc=;
   web_doc=1;
   wiki="CCN";
   url="CCNBook/Sims/Motor/FSA";
   full_url="https://grey.colorado.edu/CompCogNeuro/index.php/CCNBook/Sims/Motor/FSA";
   text_size=1;
   text="<html>
<head>Finite State Automaton</head>
<body>
= Finite State Automaton =

* To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.

We begin by exploring the network [[.T3Tab.CopyContext]].

Begin by clicking on the CopyContext tab in the middle window and then click the Build button at the bottom left to build out the network.  Then, click on <code>r.wt </code>to make sure it is the display variable and observe the connectivity. In particular, click on several Context layer units.

Note in particular that each context layer unit has only a single receiving weight from a single hidden unit.  The context units use this connection to determine which hidden unit to update from (but the weight is not used, and just has a random value).  Otherwise, the network is standardly fully connected.  Notice also that there is a seemingly extraneous <code>Targets</code> layer, which is not connected to anything.  This is simply for display purposes -- it shows the two possible valid outputs, which can be compared to the actual output.

Let's view the activations, and see a few trials of learning.  

* Click on <code>act</code> in the network. Make sure the network has been initialized ([[.LeabraTrainBatchSeedNThr.Init()|Train: Init]]), and then you can <code>Step Settle</code> through a trial.

This is the minus phase for the beginning of a <code>sequence</code> (one pass through the FSA grammar), which always starts with the letter B, and the context units zeroed.  The network will produce some random expectation of which letters are coming next.  Note that there is some noise in the unit activations -- this helps them pick one unit out of the two possible ones at random.  

* Then Step Settle again to see the plus phase.

You should see that one of the two possible subsequent letters (T or P) is strongly activated -- this unit indicates which letter actually came next in the sequence.  Thus, the network only ever learns about one of the two possible subsequent letters on each trial (because they are chosen at random).  It has to learn that a given node has two possible outputs by integrating experience over different trials, which is one of the things that makes this a somewhat challenging task to learn.

An interesting aspect of this task is that even when the network has done as well as it possibly could, it should still make roughly 50 percent \"errors,\" because it ends up making a discrete guess as to which output will come next, which can only be right 50 percent of the time.  This could cause problems for learning if it introduced a systematic error signal that would constantly increase or decrease the bias weights.  This is not a problem because a unit will be correctly active about as often as it will be incorrectly inactive, so the overall net error will be zero.  Note that if we allowed both units to become active this would not be the case, because one of the units would always be incorrectly active, and this would introduce a net negative error and large negative bias weights (which would eventually shut down the activation of the output units).

One possible objection to having the network pick one output at random instead of allowing both to be on, is that it somehow means that the network will be \"surprised\" by the actual response when it differs from the guess (i.e., about 50% of the time).  This is actually not the case, because the hidden layer representation remains essentially the same for both outputs (reflecting the node identity, more or less), and thus does not change when the actual output is presented in the plus phase.  Thus, the \"higher level\" internal representation encompasses both possible outputs, while the lower-level output representation randomly chooses one of them.  This situation will be important later as we consider how networks can efficiently represent multiple items (see chapter 7 for further discussion).

To monitor the network's performance over learning, we need an error statistic that converges to zero when the network has learned the task perfectly (which is not the case with the standard SSE, due to the randomness of the task).  Thus, we have a new statistic that reports an error (of 1) if the output unit was not one of the two possible outputs (i.e., as shown in the <code>Targets</code> layer).  This is labeled as <code>fsa_err_sum</code> in the log displays.

* Now, continue to Step Settle into the minus phase of the next event in the sequence.

You should see now that the <code>Context</code> units are updated with a copy of the prior hidden unit activations.  

* To verify this, click on <code>act_p</code>.

This will show the plus phase activations from the previous event.  

* Now you can continue to Step Settle or Trial through the rest of the sequence.  Once you get a feel for the activity states, you can [[.LeabraTrainBatchSeedNThr.Run()|Run]] and watch the training log in [[.T3Tab.CopyContext]]. (You may want to click off the network <code> display </code> in [[.T3Tab.CopyContext]] to speed up processing, or just switch to viewing the [[.T3Tab.EpochOutputData]] tab).

As the network runs, a special program (<code>ReberGenData</code>) dynamically creates 25 new sequences of events every other epoch (to speed the computation, because the program is relatively slow).  Thus, instead of creating a whole bunch of training examples from the underlying FSA in advance, they are created on-line with a program that implements the Reber grammar FSA.

Because it may take a while to train, you can opt to load a fully trained network and its training log.
* To do so, [[.LeabraTrainBatchSeedNThr.Stop()|Stop]] the network at any time via [[.PanelTab.ControlPanel]]. 
*  To load the network, click on the CopyContext network in the left browser under the networks section and select [[.networks.CopyContext.LoadWeights()|Load Weights]] from the Object menu (or the Button), and choose <code>fsa.trained.wts</code>. 
*  To load the log file, click on the EpochOutputData object under data/OutputData in the left browser panel, then do [[.EpochOutputData.LoadAnyData_gui()|Load Any Data]] button, and select <code>fsa.epc.dat</code>.

The network should take anywhere between 12 and 1500 epochs to learn the problem to the point where it gets zero errors in one epoch (this was the range for ten random networks we ran).  The pre-trained network took 12 epochs to get to this first zero, but we trained it longer (622 epochs total) to get it to the point where it got 4 zeros in a row.  This stamping in of the representations makes them more robust to the noise, but the network still makes occasional errors even with this extra training.  The 12 epochs amounts to only 150 different sequences and the 622 epochs amounts to 7775 sequences (each set of 25 sequences lasts for 2 epochs).

In either case, the Leabra network is much faster than the backpropagation network used by Cleeremans, Servan-Schreiber, and McClelland (1989), which took 60,000 sequences (i.e., 4,800 epochs under our scheme).  However, we were able to train backpropagation networks with larger hidden layers (30 units instead of 3) to learn in between 136 and 406 epochs.  Thus, there is some evidence of an advantage for the additional constraints of model learning and inhibitory competition in this task, given that the Leabra networks generally learned much faster (and backpropagation required a much larger learning rate).

Now we can test the trained network to see how it has solved the problem, and also to see how well it distinguishes grammatical from ungrammatical letter strings.  

* Click on the [[.T3Tab.TrialOutputDataTest]] tab in the right panel to display the test results. Then, [[.LeabraEpochGpDataTest.Init()|Test: Init]] and <code>Step TrlTst</code> through several inputs in order to see what the hidden states look like.

This will test the network with several sequences of letters, with the results shown in the grid view on the right.  Note that the network display is being updated every cycle, so you can see the stochastic choosing of one of the two possible outputs.  The network should be producing the correct outputs, as indicated both by the  <code>fsa_err</code>  column and by the fact that the <code>Output</code> pattern is consistent with the <code>Targets</code> pattern, though it might make an occasional mistake due to the noise.

To better understand the hidden unit representations, we need a sequence of reasonable length (i.e., more than ten or so events).  In these longer sequences, the FSA has revisited various nodes due to selecting the looping path, and this revisiting will tell us about the representation of the individual nodes.  Thus, if the total number of events in the sequence was below ten (events are counted in the <code>trial</code> column of the grid view), we need to keep going to find a suitable sequence. 

* To do so, turn the network <code>Display</code> toggle off (to speed things up), and press [[.LeabraEpochGpDataTest.Run()|Test: Run]] until you find a sequence with ten or more events.  After running the sequence with ten or more  events, press [[.ClusterHidden.Init()|Cluster]], and view the [[.T3Tab.clust_data]].

This will bring up a cluster plot of the hidden unit states for each event (e.g., figure 6.15).  Figure 6.15 provides a decoding of the cluster plot elements.

<hr>

'''Question 6.4.''' <em> Interpret the cluster plot you obtained (especially the clusters with events at zero distance) in terms of the correspondence between hidden states and the current node versus the current letter.   Remember that current node and current letter information is reflected in the letter and number before the arrow.</em>

<hr>

* Now, switch the <code>test_env</code> on [[.ControlPanel]] from <code>TRAIN_ENV</code> to <code>RANDOM</code>, and hit <code>Apply</code> . Next, make sure to view [[.T3Tab.TrialOutputDataTest]], and [[.LeabraEpochGpDataTest.Run()|Test: Run]] again.

This produces a random sequence of letters.  Obviously, the network is not capable of predicting which letter will come next, and so it makes lots of errors.  Thus, one could use this network as a grammaticality detector, to determine if a given string fits the grammar.  In this sense, the network has incorporated the FSA structure itself into its own representations.

When you are done with this simulation, you can either close this project in preparation for loading the next project, or you can quit completely from the simulator.

</body>
</html>
";
   html_text="<!DOCTYPE html><html lang=\"en\" dir=\"ltr\" class=\"client-js\"><head>
<meta charset=\"UTF-8\">
<title>CCNBook/Sims/Motor/FSA - Computational Cognitive Neuroscience Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\\s)client-nojs(\\s|$)/, \"$1client-js$2\" );</script>
<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":!1,\"wgNamespaceNumber\":0,\"wgPageName\":\"CCNBook/Sims/Motor/FSA\",\"wgTitle\":\"CCNBook/Sims/Motor/FSA\",\"wgCurRevisionId\":1954,\"wgRevisionId\":1954,\"wgArticleId\":566,\"wgIsArticle\":!0,\"wgIsRedirect\":!1,\"wgAction\":\"view\",\"wgUserName\":null,\"wgUserGroups\":[\"*\"],\"wgCategories\":[],\"wgBreakFrames\":!1,\"wgPageContentLanguage\":\"en\",\"wgPageContentModel\":\"wikitext\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgDefaultDateFormat\":\"dmy\",\"wgMonthNames\":[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"wgMonthNamesShort\":[\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"wgRelevantPageName\":\"CCNBook/Sims/Motor/FSA\",\"wgRelevantArticleId\":566,\"wgIsProbablyEditable\":!1,\"wgRestrictionEdit\":[],\"wgRestrictionMove\":[],\"sfgAutocompleteValues\":[],\"sfgAutocompleteOnAllChars\":!1,\"sfgFieldProperties\":[],
\"sfgDependentFields\":[],\"sfgShowOnSelect\":[],\"sfgScriptPath\":\"/CompCogNeuro/extensions/SemanticForms\",\"wgSVGEditEditor\":\"http://svg-edit.googlecode.com/svn/trunk/editor/svg-editor.html\",\"wgHeaderTabsTabIndexes\":[],\"wgWikiEditorEnabledModules\":{\"toolbar\":!0,\"dialogs\":!0,\"preview\":!0,\"publish\":!1},\"wgCategoryTreePageCategoryOptions\":\"{\\\"mode\\\":0,\\\"hideprefix\\\":20,\\\"showcount\\\":true,\\\"namespaces\\\":false}\"});mw.loader.implement(\"user.options\",function($,jQuery){mw.user.options.set({\"variant\":\"en\"});});mw.loader.implement(\"user.tokens\",function($,jQuery){mw.user.tokens.set({\"editToken\":\"+\\\\\",\"patrolToken\":\"+\\\\\",\"watchToken\":\"+\\\\\"});});mw.loader.load([\"ext.smw.style\",\"ext.smw.tooltips\",\"mediawiki.page.startup\",\"mediawiki.legacy.wikibits\",\"skins.vector.js\"]);
} );</script>
<link rel=\"stylesheet\" href=\"/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/extensions/HeaderTabs/skins/ext.headertabs.large.css\">
<meta name=\"ResourceLoaderDynamicStyles\" content=\"\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector\">
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}</style>
<script async=\"\" src=\"/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector\"></script>
<meta name=\"generator\" content=\"MediaWiki 1.26.4\">
<link rel=\"ExportRDF\" type=\"application/rdf+xml\" title=\"CCNBook/Sims/Motor/FSA\" href=\"/CompCogNeuro/index.php?title=Special:ExportRDF/CCNBook/Sims/Motor/FSA&amp;xmlmime=rdf\">
<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
<link rel=\"EditURI\" type=\"application/rsd+xml\" href=\"https://grey.colorado.edu/CompCogNeuro/api.php?action=rsd\">
<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
<!--[if lt IE 7]><style type=\"text/css\">body{behavior:url(\"/CompCogNeuro/skins/Vector/csshover.min.htc\")}</style><![endif]-->
</head>
<body class=\"mediawiki ltr sitedir-ltr ns-0 ns-subject page-CCNBook_Sims_Motor_FSA skin-vector action-view\">
		<div id=\"mw-page-base\" class=\"noprint\"></div>
		<div id=\"mw-head-base\" class=\"noprint\"></div>
		<div id=\"content\" class=\"mw-body\" role=\"main\">
			<a id=\"top\"></a>

						<div class=\"mw-indicators\">
</div>
			<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"en\">CCNBook/Sims/Motor/FSA</h1>
									<div id=\"bodyContent\" class=\"mw-body-content\">
									<div id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</div>
								<div id=\"contentSub\"></div>
												<div id=\"jump-to-nav\" class=\"mw-jump\">
					Jump to:					<a href=\"#mw-head\">navigation</a>, 					<a href=\"#p-search\">search</a>
				</div>
				<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\"><h1><span class=\"mw-headline\" id=\"Finite_State_Automaton_.28FSA.29:_Temporal_Context_and_Sequences\">Finite State Automaton (FSA): Temporal Context and Sequences</span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/3/32/fsa.proj\" class=\"internal\" title=\"fsa.proj\">fsa.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\" class=\"mw-redirect\">Emergent</a>)</li>
<li> Additional files for pre-trained weights and epoch data (optional):
<ul><li> <a href=\"/mediawiki/sites/CompCogNeuro/images/f/fd/fsa.trained.wts\" class=\"internal\" title=\"fsa.trained.wts\">fsa.trained.wts</a></li>
<li> <a href=\"/mediawiki/sites/CompCogNeuro/images/f/f8/fsa.epc.dat\" class=\"internal\" title=\"fsa.epc.dat\">fsa.epc.dat</a></li></ul></li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CCNBook/Sims/All\" title=\"CCNBook/Sims/All\">CCNBook/Sims/All</a> or <a href=\"/CompCogNeuro/index.php/CCNBook/Motor\" title=\"CCNBook/Motor\">Motor Control and Reinforcement Learning Chapter</a>.
</p>
<h1><span class=\"mw-headline\" id=\"Project_Documentation\">Project Documentation</span></h1>
<p>This simulation illustrates the learning of sequences by the storing of the network's recent activation history as a \"temporal context\" for processing the current inputs.  In this way, the network learns to (e.g.,) \"expect B\" when A just occurred, and \"expect C\" when A then B just occurred. 
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> It is recommended that you <a href=\"/CompCogNeuro/index.php?title=.docs.ProjectDocs.OpenInWindow()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".docs.ProjectDocs.OpenInWindow() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">click here to undock</span></a> this document from the main project window. Use the Window menu to find this window if you lose it, and you can always return to this document by browsing to this document from the <span style=\"background:#FFFFD0\"><tt><b>docs</b></tt></span> section in the left browser panel of the project's main window. <br>
</td></tr>
</tbody></table>
<p>We begin by exploring the network <a href=\"/CompCogNeuro/index.php?title=.T3Tab.CopyContext&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CopyContext (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">CopyContext</span></a>.
</p><p>Click on <span style=\"background:#FFFFD0\"><tt><b>r.wt</b></tt></span> and observe the connectivity by selecting individual units throughout the network.
</p><p>Note in particular that the <code>Context</code> layer units have a single receiving weight from the <code>Hidden</code> units.  The context units use this connection to determine which hidden unit to update from (but the weight is not used, and just has a random value).  Otherwise, the network is standardly fully connected.  Notice also that there is a seemingly extraneous <code>Targets</code> layer, which is not connected to anything.  This is simply for display purposes -- it shows the two possible valid outputs, which can be compared to the actual output.
</p><p>Let's view the activations, and see a few trials of learning.  
</p>
<ul><li> Click on <span style=\"background:#FFFFD0\"><tt><b>act</b></tt></span> in the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.CopyContext&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CopyContext (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">CopyContext</span></a> network display to show the activations. Make sure the network has been initialized (<a href=\"/CompCogNeuro/index.php?title=.LeabraTrainBatchSeedNThr.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".LeabraTrainBatchSeedNThr.Init() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">Init</span></a>), and then you can start to step through a trial by clicking once on the <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Settle</tt></span> button at the bottom of the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">ControlPanel</span></a>.</li></ul>
<p>This is the minus phase for the beginning of a <code>sequence</code> (one pass through the FSA grammar), which always starts with the letter B, and the context units zeroed.  The network will produce some random expectation of which letters are coming next.  Note that there is some noise in the unit activations -- this helps them pick one unit out of the two possible ones at random.  
</p>
<ul><li> Then, step again (<span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Settle</tt></span>) to see the plus phase.</li></ul>
<p>You should see that one of the two possible subsequent letters (T or P) is strongly activated -- this unit indicates which letter actually came next in the sequence.  Thus, the network only ever learns about one of the two possible subsequent letters on each trial (because they are chosen at random).  It has to learn that a given node has two possible outputs by integrating experience over different trials, which is one of the things that makes this a somewhat challenging task to learn.
</p><p>An interesting aspect of this task is that even when the network has done as well as it possibly could, it should still make roughly 50 percent \"errors,\" because it ends up making a discrete guess as to which output will come next, which can only be right 50 percent of the time.  This could cause problems for learning if it introduced a systematic error signal that would constantly increase or decrease the bias weights.  This is not a problem because a unit will be correctly active about as often as it will be incorrectly inactive, so the overall net error will be zero.  Note that if we allowed both units to become active this would not be the case, because one of the units would always be incorrectly active, and this would introduce a net negative error and large negative bias weights (which would eventually shut down the activation of the output units).
</p><p>One possible objection to having the network pick one output at random instead of allowing both to be on, is that it somehow means that the network will be \"surprised\" by the actual response when it differs from the guess (i.e., about 50\\% of the time).  This is actually not the case, because the hidden layer representation remains essentially the same for both outputs (reflecting the node identity, more or less), and thus does not change when the actual output is presented in the plus phase.  Thus, the \"higher level\" internal representation encompasses both possible outputs, while the lower-level output representation randomly chooses one of them.  This situation will be important later as we consider how networks can efficiently represent multiple items (see chapter 7 in old CECN text for further discussion).
</p><p>To monitor the network's performance over learning, we need an error statistic that converges to zero when the network has learned the task perfectly (which is not the case with the standard SSE, due to the randomness of the task).  Thus, we have a new statistic that reports an error (of 1) if the output unit was not one of the two possible outputs (i.e., as shown in the <code>Targets</code> layer).  This is labeled as <span style=\"background:#FFFFD0\"><tt><b>fsa_err_sum</b></tt></span> in the log displays.
</p>
<ul><li> Now, continue to step into the minus phase of the next event in the sequence (<span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Settle</tt></span>).</li></ul>
<p>You should see now that the <code>Context</code> units are updated with a copy of the prior hidden unit activations.  
</p>
<ul><li> To verify this, click on <span style=\"background:#FFFFD0\"><tt><b>act_p</b></tt></span> in the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.CopyContext&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CopyContext (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">CopyContext</span></a> display.</li></ul>
<p>This will show the plus phase activations from the previous event.  
</p>
<ul><li> Now you can continue to step through the rest of the sequence.  Once you get a feel for the activity states, you can <a href=\"/CompCogNeuro/index.php?title=.LeabraTrainBatchSeedNThr.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".LeabraTrainBatchSeedNThr.Run() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">Run</span></a> and watch the training log in <a href=\"/CompCogNeuro/index.php?title=.T3Tab.CopyContext&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CopyContext (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">CopyContext</span></a>. (You may want to click off the <code>Display </code> flag at the top left in  <a href=\"/CompCogNeuro/index.php?title=.PanelTab.CopyContext&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.CopyContext (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">CopyContext</span></a> to speed up processing by no longer updating the display).</li></ul>
<p>As the network runs, a special program (<code>ReberGenData</code>) dynamically creates 25 new sequences of events every other epoch (to speed the computation, because the program is relatively slow).  Thus, instead of creating a whole bunch of training examples from the underlying FSA in advance, they are created on-line with a program that implements the Reber grammar FSA.
</p><p>Because it may take a while to train, you can opt to load a fully trained network and its training log.
</p>
<ul><li> To do so, <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Stop</tt></span> the network at any time via <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">ControlPanel</span></a>. </li>
<li>  To load the the fully trained network, click on the <code>CopyContext</code> network in the left browser under the networks section and select <a href=\"/CompCogNeuro/index.php?title=.networks.CopyContext.LoadWeights()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".networks.CopyContext.LoadWeights() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">LoadWeights</span></a> from the <code>Object</code> menu, and choose <code>fsa.trained.wts</code>. </li>
<li>  To load the log file, click on the <code>EpochOutputData</code> object under <code>data/OutputData</code> in the left browser panel, then do <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>LoadAnyData</tt></span> from its <code>Data</code> menu, and select <code>fsa.epc.dat</code> (select <code>reset_first</code> if asked, to clear out any existing data).</li></ul>
<p>The network should take anywhere between 12 and 1500 epochs to learn the problem to the point where it gets zero errors in one epoch (this was the range for ten random networks we ran).  The pre-trained network took 12 epochs to get to this first zero, but we trained it longer (622 epochs total) to get it to the point where it got 4 zeros in a row.  This stamping in of the representations makes them more robust to the noise, but the network still makes occasional errors even with this extra training.  The 12 epochs amounts to only 150 different sequences and the 622 epochs amounts to 7775 sequences (each set of 25 sequences lasts for 2 epochs).
</p><p>In either case, the Leabra network is much faster than the backpropagation network used by Cleeremans, Servan-Schreiber, and McClelland (1989), which took 60,000 sequences (i.e., 4,800 epochs under our scheme).  However, we were able to train backpropagation networks with larger hidden layers (30 units instead of 3) to learn in between 136 and 406 epochs.  Thus, there is some evidence of an advantage for the additional constraints of model learning and inhibitory competition in this task, given that the Leabra networks generally learned much faster (and backpropagation required a much larger learning rate).
</p><p>Now we can test the trained network to see how it has solved the problem, and also to see how well it distinguishes grammatical from ungrammatical letter strings.  
</p>
<ul><li> Click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialOutputDataTest&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialOutputDataTest (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">TrialOutputDataTest</span></a> tab in the right panel to display the test results. Then, <a href=\"/CompCogNeuro/index.php?title=.LeabraEpochGpDataTest.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".LeabraEpochGpDataTest.Init() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">Test Init</span></a> and then step this time using the <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>StlTst</tt></span> button (\"Settle Test\") through several inputs in order to see what the hidden states look like. (Note that there are no plus phases this time, only minus, since the network is now in <code>Test</code> mode.)</li></ul>
<p>This will test the network with several sequences of letters, with the results shown in the grid view on the far right of the table (scroll purple bar at the bottom).  Note that the network display is being updated every cycle, so you can see the stochastic choosing of one of the two possible outputs.  The network should be producing the correct outputs, as indicated both by the  <code>fsa_err</code>  column and by the fact that the <code>Output</code> pattern matches the <code>Targets</code> pattern, though it might make an occasional mistake due to the noise.
</p><p>To better understand the hidden unit representations, we need a sequence of reasonable length (i.e., more than ten or so events).  In these longer sequences, the FSA has revisited various nodes due to selecting the looping path, and this revisiting will tell us about the representation of the individual nodes.  Thus, if the total number of events in the sequence was below ten (events are counted in the <code>trial</code> column of the <code>Grid View</code>), we need to keep to find a suitable sequence. 
</p>
<ul><li> To do so, turn the network <code>Display</code> flag off to speed things up (<a href=\"/CompCogNeuro/index.php?title=.T3Tab.CopyContext&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CopyContext (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">CopyContext</span></a> first to view the network, then <a href=\"/CompCogNeuro/index.php?title=.PanelTab.CopyContext&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.CopyContext (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">CopyContext</span></a> to view its control panel, Display flag OFF at top left; then <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialOutputDataTest&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialOutputDataTest (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">TrialOutputDataTest</span></a> to go back to viewing the <code>Grid View</code>). Then, press <a href=\"/CompCogNeuro/index.php?title=.LeabraEpochGpDataTest.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".LeabraEpochGpDataTest.Run() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">Test Run</span></a> several times until you find a sequence with ten or more events (may take a dozen or more Runs).  After getting/running a sequence with ten or more  events, press <a href=\"/CompCogNeuro/index.php?title=.ClusterHidden.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".ClusterHidden.Init() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">Cluster</span></a>, and view the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.clust_data&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.clust data (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">clust_data</span></a>. </li></ul>
<p><em><b>IMPORTANT NOTE:</b> You will likely have to turn on the relevant display variables in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.clust_data&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.clust data (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">clust_data</span></a> tab in the middle frame: Row Num=OFF [X]; y1= ON [Y]; y2=ON [Label].</em>
</p><p>This will bring up a cluster plot of the hidden unit states for each event. (Figure 6.15 in old CECN text provides a decoding of the cluster plot elements.)
</p><p><br>
</p>
<hr>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#90FF90;font-size:small\"><b>Question 7.4.:</b>  Interpret the cluster plot you obtained (especially the clusters with events at zero distance) in terms of the correspondence between hidden states and the current node versus the current letter.   Remember that current node and current letter information is reflected in the letter and number before the arrow.<br>
</td></tr>
</tbody></table>
<hr>
<p><br>
</p>
<ul><li> Now, switch the <span style=\"background:#FFFFD0\"><tt><b>train_env</b></tt></span> variable in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">ControlPanel</span></a> from <code>TRAIN_ENV</code> to <code>RANDOM</code>, and hit <code>Apply</code>. Next, after making sure to view <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialOutputDataTest&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialOutputDataTest (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">TrialOutputDataTest</span></a>, <a href=\"/CompCogNeuro/index.php?title=.LeabraEpochGpDataTest.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".LeabraEpochGpDataTest.Run() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">Test Run</span></a> again.</li></ul>
<p><br>
This produces a random sequence of letters.  Obviously, the network is not capable of predicting which letter will come next, and so it makes lots of errors.  Thus, one could use this network as a grammaticality detector, to determine if a given string fits the grammar.  In this sense, the network has incorporated the FSA structure itself into its own representations.
</p><p><br>
</p>
<h3><span class=\"mw-headline\" id=\"All_done\">All done</span></h3>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> You may now close the project (use the window manager close button on the project window or <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>File/Close Project</tt></span> menu item) and then open a new one, or just quit emergent entirely by doing <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Quit emergent</tt></span> menu option or clicking the close button on the root window. <br>
</td></tr>
</tbody></table>

<!-- 
NewPP limit report
Cached time: 20191002080057
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.184 seconds
Real time usage: 0.213 seconds
Preprocessor visited node count: 338/1000000
Preprocessor generated node count: 1074/1000000
Post?expand include size: 7468/2097152 bytes
Template argument size: 2159/2097152 bytes
Highest expansion depth: 6/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%   47.980      1 - -total
 33.09%   15.879      1 - Template:DocEditDialog
 27.04%   12.973      2 - Template:cmd
 25.75%   12.353     23 - Template:emerlink
 10.84%    5.199      8 - Template:fun
 10.25%    4.916      6 - Template:var
  9.06%    4.349      1 - Template:DocQuit
  6.17%    2.959      1 - Template:hwq
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:566-0!*!0!!*!*!* and timestamp 20191002080057 and revision id 1954
 -->
</div>					<div class=\"printfooter\">
						Retrieved from \"<a dir=\"ltr\" href=\"https://grey.colorado.edu/CompCogNeuro/index.php?title=CCNBook/Sims/Motor/FSA&amp;oldid=1954\">https://grey.colorado.edu/CompCogNeuro/index.php?title=CCNBook/Sims/Motor/FSA&amp;oldid=1954</a>\"					</div>
				<div id=\"catlinks\" class=\"catlinks catlinks-allhidden\"></div>				<div class=\"visualClear\"></div>
							</div>
		</div>
		<div id=\"mw-navigation\">
			<h2>Navigation menu</h2>

			<div id=\"mw-head\">
									<div id=\"p-personal\" role=\"navigation\" class=\"\" aria-labelledby=\"p-personal-label\">
						<h3 id=\"p-personal-label\">Personal tools</h3>
						<ul>
							<li id=\"pt-createaccount\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CCNBook%2FSims%2FMotor%2FFSA&amp;type=signup\" title=\"You are encouraged to create an account and log in; however, it is not mandatory\">Create account</a></li><li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CCNBook%2FSims%2FMotor%2FFSA\" title=\"You are encouraged to log in; however, it is not mandatory [o]\" accesskey=\"o\">Log in</a></li>						</ul>
					</div>
									<div id=\"left-navigation\">
										<div id=\"p-namespaces\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-namespaces-label\">
						<h3 id=\"p-namespaces-label\">Namespaces</h3>
						<ul>
															<li id=\"ca-nstab-main\" class=\"selected\"><span><a href=\"/CompCogNeuro/index.php/CCNBook/Sims/Motor/FSA\" title=\"View the content page [c]\" accesskey=\"c\">Page</a></span></li>
															<li id=\"ca-talk\" class=\"new\"><span><a href=\"/CompCogNeuro/index.php?title=Talk:CCNBook/Sims/Motor/FSA&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [t]\" accesskey=\"t\" rel=\"discussion\">Discussion</a></span></li>
													</ul>
					</div>
										<div id=\"p-variants\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-variants-label\">
												<h3 id=\"p-variants-label\">
							<span>Variants</span><a href=\"#\"></a>
						</h3>

						<div class=\"menu\">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id=\"right-navigation\">
										<div id=\"p-views\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-views-label\">
						<h3 id=\"p-views-label\">Views</h3>
						<ul>
															<li id=\"ca-view\" class=\"selected\"><span><a href=\"/CompCogNeuro/index.php/CCNBook/Sims/Motor/FSA\">Read</a></span></li>
															<li id=\"ca-viewsource\"><span><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Motor/FSA&amp;action=edit\" title=\"This page is protected.
You can view its source [e]\" accesskey=\"e\">View source</a></span></li>
															<li id=\"ca-history\" class=\"collapsible\"><span><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Motor/FSA&amp;action=history\" title=\"Past revisions of this page [h]\" accesskey=\"h\">View history</a></span></li>
													</ul>
					</div>
										<div id=\"p-cactions\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-cactions-label\">
						<h3 id=\"p-cactions-label\"><span>More</span><a href=\"#\"></a></h3>

						<div class=\"menu\">
							<ul>
															</ul>
						</div>
					</div>
										<div id=\"p-search\" role=\"search\">
						<h3>
							<label for=\"searchInput\">Search</label>
						</h3>

						<form action=\"/CompCogNeuro/index.php\" id=\"searchform\">
							<div id=\"simpleSearch\">
							<input type=\"search\" name=\"search\" placeholder=\"Search\" title=\"Search Computational Cognitive Neuroscience Wiki [f]\" accesskey=\"f\" id=\"searchInput\"><input type=\"hidden\" value=\"Special:Search\" name=\"title\"><input type=\"submit\" name=\"fulltext\" value=\"Search\" title=\"Search the pages for this text\" id=\"mw-searchButton\" class=\"searchButton mw-fallbackSearchButton\"><input type=\"submit\" name=\"go\" value=\"Go\" title=\"Go to a page with this exact name if it exists\" id=\"searchButton\" class=\"searchButton\">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id=\"mw-panel\">
				<div id=\"p-logo\" role=\"banner\"><a class=\"mw-wiki-logo\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page\"></a></div>
						<div class=\"portal\" role=\"navigation\" id=\"p-navigation\" aria-labelledby=\"p-navigation-label\">
			<h3 id=\"p-navigation-label\">Navigation</h3>

			<div class=\"body\">
									<ul>
						<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [z]\" accesskey=\"z\">Main page</a></li><li id=\"n-CCN-Book\"><a href=\"/CompCogNeuro/index.php/CCNBook/Main\">CCN Book</a></li><li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"A list of recent changes in the wiki [r]\" accesskey=\"r\">Recent changes</a></li><li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [x]\" accesskey=\"x\">Random page</a></li><li id=\"n-help\"><a href=\"https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents\" title=\"The place to find out\">Help</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-tb\" aria-labelledby=\"p-tb-label\">
			<h3 id=\"p-tb-label\">Tools</h3>

			<div class=\"body\">
									<ul>
						<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CCNBook/Sims/Motor/FSA\" title=\"A list of all wiki pages that link here [j]\" accesskey=\"j\">What links here</a></li><li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CCNBook/Sims/Motor/FSA\" title=\"Recent changes in pages linked from this page [k]\" accesskey=\"k\">Related changes</a></li><li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"A list of all special pages [q]\" accesskey=\"q\">Special pages</a></li><li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Motor/FSA&amp;oldid=1954\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-info\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Motor/FSA&amp;action=info\" title=\"More information about this page\">Page information</a></li><li id=\"t-smwbrowselink\"><a href=\"/CompCogNeuro/index.php/Special:Browse/CCNBook/Sims/Motor/FSA\" rel=\"smw-browse\">Browse properties</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-coll-print_export\" aria-labelledby=\"p-coll-print_export-label\">
			<h3 id=\"p-coll-print_export-label\">Print/export</h3>

			<div class=\"body\">
									<ul>
						<li id=\"coll-create_a_book\"><a href=\"/CompCogNeuro/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=CCNBook%2FSims%2FMotor%2FFSA\">Create a book</a></li><li id=\"coll-download-as-rl\"><a href=\"/CompCogNeuro/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=CCNBook%2FSims%2FMotor%2FFSA&amp;oldid=1954&amp;writer=rl\">Download as PDF</a></li><li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Motor/FSA&amp;printable=yes\" title=\"Printable version of this page [p]\" accesskey=\"p\">Printable version</a></li>					</ul>
							</div>
		</div>
				</div>
		</div>
		<div id=\"footer\" role=\"contentinfo\">
							<ul id=\"footer-info\">
											<li id=\"footer-info-lastmod\"> This page was last modified on 27 June 2011, at 15:04.</li>
									</ul>
							<ul id=\"footer-places\">
											<li id=\"footer-places-privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
											<li id=\"footer-places-about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
											<li id=\"footer-places-disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
									</ul>
										<ul id=\"footer-icons\" class=\"noprint\">
											<li id=\"footer-copyrightico\">
							<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-sa/3.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://licensebuttons.net/l/by-sa/3.0/88x31.png\"></a><br>This work is licensed under a <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-sa/3.0/\">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.						</li>
											<li id=\"footer-poweredbyico\">
							<a href=\"//www.mediawiki.org/\"><img src=\"/CompCogNeuro/resources/assets/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\" srcset=\"/CompCogNeuro/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /CompCogNeuro/resources/assets/poweredby_mediawiki_176x62.png 2x\" width=\"88\" height=\"31\"></a><a href=\"https://www.semantic-mediawiki.org/wiki/Semantic_MediaWiki\"><img src=\"/CompCogNeuro/extensions/SemanticMediaWiki/resources/images/smw_button.png\" alt=\"Powered by Semantic MediaWiki\" width=\"88\" height=\"31\"></a>						</li>
									</ul>
						<div style=\"clear:both\"></div>
		</div>
		<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.loader.state({\"user\":\"ready\",\"user.groups\":\"ready\"});mw.loader.load([\"mediawiki.action.view.postEdit\",\"site\",\"mediawiki.user\",\"mediawiki.hidpi\",\"mediawiki.page.ready\",\"mediawiki.searchSuggest\",\"ext.headertabs\"]);
} );</script><script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgBackendResponseTime\":161});
} );</script>
	

</body></html>";
  };
  taDoc @[1] {
   name="ChangeLog";
   desc=;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>


<li>Thu Oct  3 00:27:40 2019 version: 0.0.5 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416015 a few more minor tweaks



<li>Wed Oct  2 23:47:10 2019 version: 0.0.4 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416014 few more params normalized.  still discrepancy with Go version.




<li>Wed Oct  2 03:08:29 2019 version: 0.0.3 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416013 a few other param fixes & notes




<li>Wed Oct  2 01:49:49 2019 version: 0.0.2 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416012 major cleanup to new cannonical form and many param tests -- really depends on deep-to-deep ctxt and input to deep ctxt, and momentum for closing the deal



<li>Tue Jan 23 12:47:23 2018 version: 0.0.1 user: rohrlich file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 415377 Updates to test code to work with 8.5 unit api
</ul>
</body>
</html>
";
   html_text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>
<P>
<P>
<li>Thu Oct  3 00:27:40 2019 version: 0.0.5 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416015 a few more minor tweaks
<P>
<P>
<P>
<li>Wed Oct  2 23:47:10 2019 version: 0.0.4 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416014 few more params normalized.  still discrepancy with Go version.
<P>
<P>
<P>
<P>
<li>Wed Oct  2 03:08:29 2019 version: 0.0.3 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416013 a few other param fixes & notes
<P>
<P>
<P>
<P>
<li>Wed Oct  2 01:49:49 2019 version: 0.0.2 user: oreilly file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 416012 major cleanup to new cannonical form and many param tests -- really depends on deep-to-deep ctxt and input to deep ctxt, and momentum for closing the deal
<P>
<P>
<P>
<li>Tue Jan 23 12:47:23 2018 version: 0.0.1 user: rohrlich file_name: <code>fsa_deep_trc.proj</code> <br>
svn rev: 415377 Updates to test code to work with 8.5 unit api
</ul>
</body>
</html>
";
  };
 };
 wizards {
  name="wizards";
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {name="NO_CLIP": value=1: val_type_fixed=0: };
   };
   name="LeabraWizard_1";
  };
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  master_and_clones=0;
  ControlPanel @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @[0] {name="DocLink": doc=.docs[0]$$: };
    UserDataItem @[1] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ControlPanel";
   cp_state=REGULAR;
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=ControlPanelMember;
    el_def=0;
    ControlPanelMember @[0] {
     label="LeabraTrain_network";
     short_label=0;
     cust_label=1;
     desc=" object pointer value -- this is not the object itself, just a pointer to it -- object must exist somewhere. if it is in this program's .objs, then the name will be automatically set -- this is the current actual value of the variable at all times for global variables, and is used as an initialization value for local variables (they start with this value, but what you see here is NOT their current value as the program runs)";
     cust_desc=0;
     base=.programs.gp[0][1].args[0]$$;
     mbr=ProgVar::object_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="0:1:0.1": notes="": };
    };
    ControlPanelMember @[1] {
     label="test_env";
     short_label=0;
     cust_label=1;
     desc=" current integer value";
     cust_desc=0;
     base=.programs.gp[2][0].vars[2].dyn_enum_val$$;
     mbr=DynEnum::value;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="0:1:0.1": notes="": };
    };
    ControlPanelMember @[2] {
     label="cycle_qtr";
     short_label=1;
     cust_label=0;
     desc="[Default: true]  one CycleRun runs for a full quarter number of actual cycles -- this greatly speeds up processing by reducing threading overhead, but prevents e.g., interactive viewing at the individual cycle level -- this is not saved -- have to re-engage it when needed, to prevent unintentionally slowing everything down";
     cust_desc=0;
     base=.networks[0].times$$;
     mbr=LeabraTimes::cycle_qtr;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[3] {
     label="LeabraCycle_update_net_view";
     short_label=0;
     cust_label=1;
     desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
     cust_desc=1;
     base=.programs.gp[0][5].vars[0]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[4] {
     label="LeabraEpoch_step_on_err";
     short_label=0;
     cust_label=1;
     desc="when you step at the Epoch level, this will automatically step through to the next point at which an error was made -- you can use the netview history to replay what happend";
     cust_desc=1;
     base=.programs.gp[0][2].vars[3]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[5] {
     label="leabra_tictxt_delta_dwt";
     short_label=0;
     cust_label=0;
     desc=" use simple delta-dwt change rule, instead of full xcal learning rule -- key problem is that delta-dwt does NOT include hebbian component for controlling hog-unit dynamics, etc";
     cust_desc=0;
     base=.networks[0].specs[1].children[1]$$;
     mbr=DeepCtxtConSpec::delta_dwt;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
   };
   mths {
    name="mths";
    el_typ=ControlPanelMethod;
    el_def=0;
    group_type=GT_BUTTONS;
    ControlPanelMethod @[0] {
     label="Train_Init";
     short_label=0;
     cust_label=1;
     desc=" run init_code, global variables retain current values unless reset in the init_code";
     cust_desc=0;
     base=.programs.gp[0][1]$$;
     mth=Program::Init;
    };
    ControlPanelMethod @[1] {
     label="Step";
     short_label=0;
     cust_label=0;
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.programs.gp[0][1]$;
     mth=Program::Step_Gui;
    };
    ControlPanelMethod @[2] {
     label="Run";
     short_label=0;
     cust_label=0;
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.programs.gp[0][1]$;
     mth=Program::Run_Gui;
    };
    ControlPanelMethod @[3] {
     label="Stop";
     short_label=0;
     cust_label=0;
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.programs.gp[0][1]$;
     mth=Program::Stop;
    };
    ControlPanelMethod @[4] {
     label="Test_Init";
     short_label=0;
     cust_label=1;
     desc=" run init_code, global variables retain current values unless reset in the init_code";
     cust_desc=0;
     base=.programs.gp[1][0]$$;
     mth=Program::Init;
    };
    ControlPanelMethod @[5] {
     label="Run";
     short_label=0;
     cust_label=0;
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.programs.gp[1][0]$;
     mth=Program::Run_Gui;
    };
    ControlPanelMethod @[6] {
     label="Step";
     short_label=0;
     cust_label=0;
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.programs.gp[1][0]$;
     mth=Program::Step_Gui;
    };
    ControlPanelMethod @[7] {
     label="Cluster";
     short_label=0;
     cust_label=1;
     desc=" run init_code, global variables retain current values unless reset in the init_code";
     cust_desc=0;
     base=.programs.gp[3][0]$$;
     mth=Program::Init;
    };
    ControlPanelMethod @[8] {
     label="Defaults";
     short_label=0;
     cust_label=1;
     desc="reset all params to default values";
     cust_desc=1;
     base=.programs.gp[2][4]$$;
     mth=Program::Run_Gui;
    };
    ControlPanelMethod @[9] {
     label="Net_Build";
     short_label=0;
     cust_label=1;
     desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
     cust_desc=0;
     base=.networks[0]$$;
     mth=LeabraNetwork::Build;
    };
   };
  };
  ClusterRun @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ClusterRun";
   cp_state=REGULAR;
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=ControlPanelMember;
    el_def=0;
    ControlPanelMember @[0] {
     label="lrate";
     short_label=1;
     cust_label=0;
     desc="[Default: 0.04]  learning rate -- how fast the weights change per experience -- since version 7.8.5, a hidden factor of 2 has been removed, so this should be 2x what you used to use previously (e.g., default used to be .02, now is .04) -- this governs the rate of change for the fastest adapting weights -- see slow_wts for a more slowly adapting factor";
     cust_desc=0;
     base=.networks[0].specs[1]$$;
     mbr=LeabraConSpec::lrate;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="0:1:0.1": notes=".02 much faster but 1 batch failed to learn, but works with .1 td": };
    };
    ControlPanelMember @[1] {
     label="n_batches";
     short_label=1;
     cust_label=0;
     desc="number of batches to run";
     cust_desc=1;
     base=.programs.gp[0][0].vars[2]$$;
     mbr=ProgVar::int_val;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[2] {
     label="batch_start";
     short_label=1;
     cust_label=0;
     desc="batch number to start on";
     cust_desc=1;
     base=.programs.gp[0][0].vars[1]$$;
     mbr=ProgVar::int_val;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[3] {
     label="deep_to_deep_ctxt_wt_scale_rel";
     short_label=0;
     cust_label=0;
     desc=" [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)";
     cust_desc=0;
     base=.networks[0].specs[1].children[1].children[1].wt_scale$$;
     mbr=WtScaleSpec::rel;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="1 = best, *essential*": };
    };
    ControlPanelMember @[4] {
     label="trc_to_deep_ctxt_wt_scale_rel";
     short_label=0;
     cust_label=1;
     desc=" [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)";
     cust_desc=0;
     base=.networks[0].specs[1].children[1].children[2].wt_scale$$;
     mbr=WtScaleSpec::rel;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="1 = best, *essential*": };
    };
    ControlPanelMember @[5] {
     label="sup_to_deep_ctxt_wt_scale_rel";
     short_label=0;
     cust_label=0;
     desc=" [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)";
     cust_desc=0;
     base=.networks[0].specs[1].children[1].children[0].wt_scale$$;
     mbr=WtScaleSpec::rel;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="1 = best, standard": };
    };
    ControlPanelMember @[6] {
     label="decay_trial";
     short_label=0;
     cust_label=1;
     desc=" [1 to clear] proportion decay of state vars between trials";
     cust_desc=0;
     base=.networks[0].specs[3].decay$$;
     mbr=LayerDecaySpec::trial;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="0 normal": };
    };
    ControlPanelMember @[7] {
     label="del_inhib_prv_trl";
     short_label=0;
     cust_label=1;
     desc=" proportion of per-unit net input on previous trial to add in as inhibition ";
     cust_desc=0;
     base=.networks[0].specs[3].del_inhib$$;
     mbr=LeabraDelInhib::prv_trl;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes=".1 slightly better": };
    };
    ControlPanelMember @[8] {
     label="lay_inhib_gi";
     short_label=0;
     cust_label=1;
     desc="[Default: 1.8]  [1.5-2.3 typical, can go lower or higher as needed] overall inhibition gain -- this is main paramter to adjust to change overall activation levels -- it scales both the the ff and fb factors uniformly -- also see inhib_adapt which will adapt an additional multiplier on this overall inhibition to keep layer near target activation value specified in avg_act.targ_init";
     cust_desc=0;
     base=.networks[0].specs[3].lay_inhib$$;
     mbr=LeabraInhibSpec::gi;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="1.8 fine": };
    };
    ControlPanelMember @[9] {
     label="input_lay_inhib_gi";
     short_label=0;
     cust_label=0;
     desc="[Default: 1.8]  [1.5-2.3 typical, can go lower or higher as needed] overall inhibition gain -- this is main paramter to adjust to change overall activation levels -- it scales both the the ff and fb factors uniformly -- also see inhib_adapt which will adapt an additional multiplier on this overall inhibition to keep layer near target activation value specified in avg_act.targ_init";
     cust_desc=0;
     base=.networks[0].specs[2].lay_inhib$$;
     mbr=LeabraInhibSpec::gi;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="2.2 good": };
    };
    ControlPanelMember @[10] {
     label="fm_trc_wt_scale_rel";
     short_label=0;
     cust_label=0;
     desc=" [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)";
     cust_desc=0;
     base=.networks[0].specs[1].children[3].wt_scale$$;
     mbr=WtScaleSpec::rel;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="0.5 default": };
    };
    ControlPanelMember @[11] {
     label="deep_fm_trc_wt_scale_rel";
     short_label=0;
     cust_label=0;
     desc=" [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)";
     cust_desc=0;
     base=.networks[0].specs[1].children[4].wt_scale$$;
     mbr=WtScaleSpec::rel;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes=".05 best -- must be small .1 sig worse": };
    };
    ControlPanelMember @[12] {
     label="hid_fm_input_wt_scale_rel";
     short_label=0;
     cust_label=0;
     desc=" [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)";
     cust_desc=0;
     base=.networks[0].specs[1].children[6].wt_scale$$;
     mbr=WtScaleSpec::rel;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[13] {
     label="hid_fm_deep_wt_scale_rel";
     short_label=0;
     cust_label=0;
     desc=" [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)";
     cust_desc=0;
     base=.networks[0].specs[1].children[7].wt_scale$$;
     mbr=WtScaleSpec::rel;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="not needed, not standard": };
    };
    ControlPanelMember @[14] {
     label="deep_mod_min";
     short_label=0;
     cust_label=1;
     desc=" minimum deep_mod value -- provides a non-zero baseline for deep-layer modulation";
     cust_desc=0;
     base=.networks[0].specs[0].deep$$;
     mbr=DeepSpec::mod_min;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="": range="": notes="no deep mod": };
    };
    ControlPanelMember @[15] {
     label="leabra_tictxt_delta_dwt";
     short_label=0;
     cust_label=0;
     desc=" use simple delta-dwt change rule, instead of full xcal learning rule -- key problem is that delta-dwt does NOT include hebbian component for controlling hog-unit dynamics, etc";
     cust_desc=0;
     base=$.networks[0].specs[1].children[1]$;
     mbr=DeepCtxtConSpec::delta_dwt;
     data {ctrl_type=CLUSTER_RUN: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
    ControlPanelMember @[16] {
     label="leabra_con_spec_0_wt_bal_on";
     short_label=0;
     cust_label=0;
     desc=" perform weight balance soft normalization? if so, maintains overall weight balance across units by progressively penalizing weight increases as a function of amount of averaged weight above a high threshold (hi_thr) and long time-average activation above an act_thr -- this is generally very beneficial for larger models where hog units are a problem, but not as much for smaller models where the additional constraints are not beneficial -- uses a sigmoidal function: wb_inc = 1 / (1 + hi_gain*(wb_avg - hi_thr) + act_gain * (act_avg - act_thr)))";
     cust_desc=0;
     base=.networks[0].specs[1].wt_bal$$;
     mbr=WtBalanceSpec::on;
     data {ctrl_type=CLUSTER_RUN: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="not a big eal either way": };
    };
    ControlPanelMember @[17] {
     label="leabra_tictxt_wt_bal_on";
     short_label=0;
     cust_label=0;
     desc=" perform weight balance soft normalization? if so, maintains overall weight balance across units by progressively penalizing weight increases as a function of amount of averaged weight above a high threshold (hi_thr) and long time-average activation above an act_thr -- this is generally very beneficial for larger models where hog units are a problem, but not as much for smaller models where the additional constraints are not beneficial -- uses a sigmoidal function: wb_inc = 1 / (1 + hi_gain*(wb_avg - hi_thr) + act_gain * (act_avg - act_thr)))";
     cust_desc=0;
     base=.networks[0].specs[1].children[1].wt_bal$$;
     mbr=WtBalanceSpec::on;
     data {ctrl_type=CLUSTER_RUN: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="todo: retest": };
    };
    ControlPanelMember @[18] {
     label="leabra_con_spec_0_dwt_norm_on";
     short_label=0;
     cust_label=0;
     desc="[Default: true]  whether to use dwt normalization, only on error-driven dwt component, based on projection-level max_avg value -- slowly decays and instantly resets to any current max";
     cust_desc=0;
     base=.networks[0].specs[1].dwt_norm$$;
     mbr=LeabraDwtNorm::on;
     data {ctrl_type=CLUSTER_RUN: is_numeric=0: is_single=1: state=EXPLORE: saved_value="true": range="": notes="essential for full convergence": };
    };
    ControlPanelMember @[19] {
     label="leabra_con_spec_0_momentum_on";
     short_label=0;
     cust_label=0;
     desc="[Default: true]  whether to use standard simple momentum ";
     cust_desc=0;
     base=.networks[0].specs[1].momentum$$;
     mbr=LeabraMomentum::on;
     data {ctrl_type=CLUSTER_RUN: is_numeric=0: is_single=1: state=EXPLORE: saved_value="true": range="": notes="\"": };
    };
    ControlPanelMember @[20] {
     label="n_under_thr";
     short_label=1;
     cust_label=0;
     desc="number of times network needs to be under stopcrit threshold to actually stop";
     cust_desc=0;
     base=.programs.gp[0][1].vars[5]$$;
     mbr=ProgVar::int_val;
     data {ctrl_type=CLUSTER_RUN: is_numeric=1: is_single=1: state=EXPLORE: saved_value="3": range="": notes="> 1 key for thorough -- gets flukey": };
    };
   };
   mths {
    name="mths";
    el_typ=ControlPanelMethod;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=1;
   proj_name="fsa_deep";
   auto_updt_interval=10;
   auto_updt_timeout=30;
   load_data_size_max=10000000;
   cluster="dream";
   clusters="dream";
   users="oreilly";
   last_submit_time="2015_10_03_01_48_51";
   notes="trc s_d_ctxt .5";
   label="trc s_d_ctxt .5";
   extra_files=;
   svn_repo="grey_run";
   repo_url="https://grey.colorado.edu/svn/clusterun";
   queue=;
   run_time="1h";
   exe_cmd="emergent";
   ram_gb=0;
   n_threads=1;
   use_cuda=0;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=0;
   enable_notes=0;
  };
 };
 active_params {
  name="active_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
 };
 archived_params {
  name="archived_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {name="N_ROWS": value=5: val_type_fixed=0: };
    };
    name="TrainInputData";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Group";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [181] "Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_1";
"Seq_1";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_3";
"Seq_3";"Seq_3";"Seq_3";"Seq_3";"Seq_4";"Seq_4";"Seq_4";"Seq_4";"Seq_4";"Seq_5";
"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_6";
"Seq_6";"Seq_6";"Seq_6";"Seq_6";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_8";
"Seq_8";"Seq_8";"Seq_8";"Seq_8";"Seq_8";"Seq_8";"Seq_8";"Seq_8";"Seq_9";"Seq_9";
"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_10";"Seq_10";
"Seq_10";"Seq_10";"Seq_10";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_12";"Seq_12";
"Seq_12";"Seq_12";"Seq_12";"Seq_12";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";
"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_14";
"Seq_14";"Seq_14";"Seq_14";"Seq_14";"Seq_15";"Seq_15";"Seq_15";"Seq_15";"Seq_15";"Seq_15";
"Seq_15";"Seq_15";"Seq_15";"Seq_15";"Seq_15";"Seq_15";"Seq_16";"Seq_16";"Seq_16";"Seq_16";
"Seq_16";"Seq_17";"Seq_17";"Seq_17";"Seq_17";"Seq_17";"Seq_17";"Seq_17";"Seq_17";"Seq_18";
"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_19";"Seq_19";"Seq_19";"Seq_19";"Seq_19";
"Seq_20";"Seq_20";"Seq_20";"Seq_20";"Seq_20";"Seq_20";"Seq_20";"Seq_20";"Seq_20";"Seq_20";
"Seq_21";"Seq_21";"Seq_21";"Seq_21";"Seq_21";"Seq_21";"Seq_21";"Seq_21";"Seq_21";"Seq_22";
"Seq_22";"Seq_22";"Seq_22";"Seq_22";"Seq_22";"Seq_22";"Seq_22";"Seq_23";"Seq_23";"Seq_23";
"Seq_23";"Seq_23";"Seq_23";"Seq_23";"Seq_23";"Seq_23";"Seq_24";"Seq_24";"Seq_24";"Seq_24";
"Seq_24";      };
     };
     String_Data @[1] {
      name="Name";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [181] "S0_B";"S2_P";"S4_V";"S5_V";"S5_E";"S0_B";"S2_P";"S4_V";"S3_P";"S5_S";
"S5_E";"S0_B";"S2_P";"S2_T";"S2_T";"S4_V";"S3_P";"S5_S";"S5_E";"S0_B";
"S1_T";"S3_X";"S5_S";"S5_E";"S0_B";"S2_P";"S4_V";"S5_V";"S5_E";"S0_B";
"S2_P";"S4_V";"S3_P";"S2_X";"S2_T";"S2_T";"S4_V";"S5_V";"S5_E";"S0_B";
"S2_P";"S4_V";"S5_V";"S5_E";"S0_B";"S2_P";"S4_V";"S5_V";"S5_E";"S0_B";
"S2_P";"S2_T";"S2_T";"S2_T";"S4_V";"S3_P";"S5_S";"S5_E";"S0_B";"S1_T";
"S3_X";"S2_X";"S2_T";"S2_T";"S4_V";"S3_P";"S5_S";"S5_E";"S0_B";"S2_P";
"S4_V";"S5_V";"S5_E";"S0_B";"S2_P";"S4_V";"S5_V";"S5_E";"S0_B";"S1_T";
"S1_S";"S3_X";"S5_S";"S5_E";"S0_B";"S1_T";"S1_S";"S1_S";"S3_X";"S2_X";
"S2_T";"S4_V";"S3_P";"S2_X";"S2_T";"S4_V";"S3_P";"S5_S";"S5_E";"S0_B";
"S2_P";"S4_V";"S5_V";"S5_E";"S0_B";"S1_T";"S1_S";"S1_S";"S3_X";"S2_X";
"S4_V";"S3_P";"S2_X";"S4_V";"S5_V";"S5_E";"S0_B";"S1_T";"S3_X";"S5_S";
"S5_E";"S0_B";"S2_P";"S4_V";"S3_P";"S2_X";"S4_V";"S5_V";"S5_E";"S0_B";
"S2_P";"S2_T";"S4_V";"S5_V";"S5_E";"S0_B";"S2_P";"S4_V";"S5_V";"S5_E";
"S0_B";"S2_P";"S2_T";"S2_T";"S4_V";"S3_P";"S2_X";"S4_V";"S5_V";"S5_E";
"S0_B";"S1_T";"S1_S";"S1_S";"S1_S";"S1_S";"S3_X";"S5_S";"S5_E";"S0_B";
"S1_T";"S3_X";"S2_X";"S2_T";"S4_V";"S5_V";"S5_E";"S0_B";"S1_T";"S1_S";
"S3_X";"S2_X";"S2_T";"S4_V";"S5_V";"S5_E";"S0_B";"S2_P";"S4_V";"S5_V";
"S5_E";      };
     };
     float_Data @[2] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 181] 1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;      };
     };
     float_Data @[3] {
      name="Targets";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 181] 1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [181] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;49;
50;51;52;53;54;55;56;57;58;59;
60;61;62;63;64;65;66;67;68;69;
70;71;72;73;74;75;76;77;78;79;
80;81;82;83;84;85;86;87;88;89;
90;91;92;93;94;95;96;97;98;99;
100;101;102;103;104;105;106;107;108;109;
110;111;112;113;114;115;116;117;118;119;
120;121;122;123;124;125;126;127;128;129;
130;131;132;133;134;135;136;137;138;139;
140;141;142;143;144;145;146;147;148;149;
150;151;152;153;154;155;156;157;158;159;
160;161;162;163;164;165;166;167;168;169;
170;171;172;173;174;175;176;177;178;179;
180;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[1] {
    name="RandomTestInputData";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Group";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [191] "Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_0";"Seq_0";
"Seq_0";"Seq_0";"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_1";
"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_2";"Seq_2";"Seq_2";"Seq_3";"Seq_3";"Seq_3";
"Seq_3";"Seq_3";"Seq_3";"Seq_3";"Seq_3";"Seq_3";"Seq_3";"Seq_3";"Seq_3";"Seq_3";
"Seq_3";"Seq_3";"Seq_4";"Seq_4";"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_5";"Seq_5";
"Seq_5";"Seq_5";"Seq_5";"Seq_6";"Seq_6";"Seq_6";"Seq_6";"Seq_6";"Seq_6";"Seq_6";
"Seq_6";"Seq_6";"Seq_6";"Seq_6";"Seq_6";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";
"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";"Seq_7";
"Seq_7";"Seq_8";"Seq_8";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";
"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_9";"Seq_10";"Seq_10";"Seq_10";"Seq_10";
"Seq_10";"Seq_10";"Seq_10";"Seq_10";"Seq_10";"Seq_10";"Seq_10";"Seq_10";"Seq_10";"Seq_11";
"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";
"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_11";"Seq_12";"Seq_12";
"Seq_12";"Seq_12";"Seq_12";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_13";
"Seq_13";"Seq_13";"Seq_13";"Seq_13";"Seq_14";"Seq_14";"Seq_15";"Seq_15";"Seq_15";"Seq_16";
"Seq_16";"Seq_16";"Seq_16";"Seq_16";"Seq_16";"Seq_16";"Seq_16";"Seq_17";"Seq_17";"Seq_18";
"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_18";"Seq_18";
"Seq_19";"Seq_19";"Seq_20";"Seq_20";"Seq_20";"Seq_20";"Seq_21";"Seq_21";"Seq_21";"Seq_21";
"Seq_22";"Seq_22";"Seq_22";"Seq_22";"Seq_22";"Seq_22";"Seq_23";"Seq_23";"Seq_24";"Seq_24";
"Seq_24";      };
     };
     String_Data @[1] {
      name="Name";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [191] "B->V_0->0";"V->B_0->0";"B->P_0->0";"P->T_0->0";"T->B_0->0";"B->B_0->0";"B->P_0->0";"P->X_0->0";"X->X_0->0";"X->B_0->0";
"B->E_0->0";"E->E_0->0";"B->P_0->0";"P->P_0->0";"P->V_0->0";"V->X_0->0";"X->T_0->0";"T->X_0->0";"X->P_0->0";"P->B_0->0";
"B->X_0->0";"X->V_0->0";"V->E_0->0";"E->E_0->0";"B->V_0->0";"V->E_0->0";"E->E_0->0";"B->B_0->0";"B->B_0->0";"B->P_0->0";
"P->S_0->0";"S->T_0->0";"T->P_0->0";"P->T_0->0";"T->X_0->0";"X->S_0->0";"S->P_0->0";"P->V_0->0";"V->T_0->0";"T->B_0->0";
"B->E_0->0";"E->E_0->0";"B->E_0->0";"E->E_0->0";"B->S_0->0";"S->S_0->0";"S->S_0->0";"S->B_0->0";"B->B_0->0";"B->P_0->0";
"P->X_0->0";"X->E_0->0";"E->E_0->0";"B->S_0->0";"S->X_0->0";"X->X_0->0";"X->V_0->0";"V->V_0->0";"V->S_0->0";"S->X_0->0";
"X->V_0->0";"V->B_0->0";"B->X_0->0";"X->E_0->0";"E->E_0->0";"B->P_0->0";"P->T_0->0";"T->V_0->0";"V->B_0->0";"B->P_0->0";
"P->S_0->0";"S->B_0->0";"B->B_0->0";"B->B_0->0";"B->P_0->0";"P->V_0->0";"V->V_0->0";"V->P_0->0";"P->B_0->0";"B->E_0->0";
"E->E_0->0";"B->E_0->0";"E->E_0->0";"B->P_0->0";"P->B_0->0";"B->T_0->0";"T->S_0->0";"S->V_0->0";"V->V_0->0";"V->S_0->0";
"S->B_0->0";"B->P_0->0";"P->S_0->0";"S->B_0->0";"B->E_0->0";"E->E_0->0";"B->V_0->0";"V->V_0->0";"V->P_0->0";"P->P_0->0";
"P->V_0->0";"V->P_0->0";"P->B_0->0";"B->X_0->0";"X->V_0->0";"V->T_0->0";"T->B_0->0";"B->E_0->0";"E->E_0->0";"B->P_0->0";
"P->S_0->0";"S->T_0->0";"T->B_0->0";"B->P_0->0";"P->S_0->0";"S->B_0->0";"B->P_0->0";"P->T_0->0";"T->T_0->0";"T->X_0->0";
"X->T_0->0";"T->S_0->0";"S->V_0->0";"V->X_0->0";"X->P_0->0";"P->P_0->0";"P->E_0->0";"E->E_0->0";"B->V_0->0";"V->T_0->0";
"T->X_0->0";"X->E_0->0";"E->E_0->0";"B->B_0->0";"B->X_0->0";"X->P_0->0";"P->B_0->0";"B->V_0->0";"V->V_0->0";"V->X_0->0";
"X->S_0->0";"S->T_0->0";"T->E_0->0";"E->E_0->0";"B->E_0->0";"E->E_0->0";"B->P_0->0";"P->E_0->0";"E->E_0->0";"B->V_0->0";
"V->B_0->0";"B->V_0->0";"V->X_0->0";"X->X_0->0";"X->P_0->0";"P->E_0->0";"E->E_0->0";"B->E_0->0";"E->E_0->0";"B->P_0->0";
"P->B_0->0";"B->P_0->0";"P->S_0->0";"S->V_0->0";"V->B_0->0";"B->S_0->0";"S->V_0->0";"V->X_0->0";"X->E_0->0";"E->E_0->0";
"B->E_0->0";"E->E_0->0";"B->V_0->0";"V->S_0->0";"S->E_0->0";"E->E_0->0";"B->T_0->0";"T->B_0->0";"B->E_0->0";"E->E_0->0";
"B->P_0->0";"P->T_0->0";"T->B_0->0";"B->T_0->0";"T->E_0->0";"E->E_0->0";"B->E_0->0";"E->E_0->0";"B->X_0->0";"X->E_0->0";
"E->E_0->0";      };
     };
     float_Data @[2] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 191] 1;0;0;0;0;0;0;0;0;0;
1;0;1;0;0;0;0;0;0;0;
0;0;0;1;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;1;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;1;0;0;0;0;1;
0;0;0;1;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;1;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;1;0;1;0;0;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;0;0;0;1;0;0;
0;0;1;0;0;1;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;1;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;1;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;0;0;0;0;
0;0;1;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;1;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;0;1;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;1;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;1;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;1;
0;0;0;0;0;1;0;0;0;0;
0;0;0;1;0;0;0;1;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;1;0;
0;1;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;1;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;1;0;1;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;0;1;0;
1;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
0;1;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;      };
     };
     float_Data @[3] {
      name="Targets";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 191] 0;0;0;1;0;0;0;0;0;0;
0;1;0;0;0;0;1;0;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
1;0;0;0;1;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;1;
0;0;1;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;1;0;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;1;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;1;0;1;0;
0;0;0;0;0;0;1;0;0;0;
0;1;0;0;0;0;0;0;0;0;
1;0;0;0;0;1;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;1;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;1;0;1;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;1;0;0;0;0;1;0;
0;1;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;0;0;1;
1;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
1;0;0;1;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;1;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;1;0;0;1;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
1;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;1;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;1;0;0;0;
0;1;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;1;0;0;
0;0;0;0;0;1;0;0;0;1;
0;0;0;0;1;0;0;0;0;0;
1;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
1;0;0;1;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;1;
0;1;0;0;0;0;0;0;0;1;
0;0;0;0;1;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;1;0;0;0;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;1;0;1;0;0;0;
0;0;0;0;0;0;0;1;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [191] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;49;
50;51;52;53;54;55;56;57;58;59;
60;61;62;63;64;65;66;67;68;69;
70;71;72;73;74;75;76;77;78;79;
80;81;82;83;84;85;86;87;88;89;
90;91;92;93;94;95;96;97;98;99;
100;101;102;103;104;105;106;107;108;109;
110;111;112;113;114;115;116;117;118;119;
120;121;122;123;124;125;126;127;128;129;
130;131;132;133;134;135;136;137;138;139;
140;141;142;143;144;145;146;147;148;149;
150;151;152;153;154;155;156;157;158;159;
160;161;162;163;164;165;166;167;168;169;
170;171;172;173;174;175;176;177;178;179;
180;181;182;183;184;185;186;187;188;189;
190;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[2] {
    name="MonitorEnv";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [4] "B->P_0->2";"P->V_2->4";"V->V_4->5";"V->E_5->0";      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 6;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=6;
      matrix_col_width=10;
      ar {
       name="ar";
      [6 5 4] 0;0;1;0;0;1;0;0;1;0;
0;1;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;1;0;0;0;
0;0;0;0;0;1;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [4] 0;1;2;3;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {name="N_ROWS": value=1: val_type_fixed=0: };
     UserDataItem @[1] {name="MAT_VAL_TEXT": value=1: val_type_fixed=0: };
     UserDataItem @[2] {name="WIDTH": value=3.299999952316284: val_type_fixed=0: };
    };
    name="UnitNames";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 1] "B";"T";"S";"X";"V";"P";;;;;
;;;;;      };
     };
     String_Data @[1] {
      name="Output";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 6;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=6;
      matrix_col_width=10;
      ar {
       name="ar";
      [6 1 1] "T";"S";"X";"V";"P";"E";      };
     };
     String_Data @[2] {
      name="Targets";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 1] "T";"S";"X";"V";"P";"E";;;;;
;;;;;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [1] 0;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_244";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_245";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_246";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="trial";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_247";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="group";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     String_Data @[4] {
      name="trial_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     String_Data @[5] {
      name="group_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[6] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_99";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="quarter";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[7] {
      name="rt_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=9;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[8] {
      name="sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[9] {
      name="ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[10] {
      name="fsa_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[1] {
    name="TrialOutputDataTest";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_63";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_64";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;      };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_65";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="trial";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] 0;1;2;3;4;5;0;1;2;3;
4;0;1;2;3;4;0;1;2;3;
4;5;6;7;8;9;10;11;12;0;
1;2;3;4;      };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] "S0_B";"S1_T";"S1_S";"S3_X";"S5_S";"S5_E";"S0_B";"S1_T";"S3_X";"S5_S";
"S5_E";"S0_B";"S1_T";"S3_X";"S5_S";"S5_E";"S0_B";"S2_P";"S2_T";"S2_T";
"S4_V";"S3_P";"S2_X";"S2_T";"S2_T";"S2_T";"S4_V";"S5_V";"S5_E";"S0_B";
"S1_T";"S3_X";"S5_S";"S5_E";      };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] "Seq_4";"Seq_4";"Seq_4";"Seq_4";"Seq_4";"Seq_4";"Seq_3";"Seq_3";"Seq_3";"Seq_3";
"Seq_3";"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_1";"Seq_2";"Seq_2";"Seq_2";"Seq_2";
"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_2";"Seq_0";
"Seq_0";"Seq_0";"Seq_0";"Seq_0";      };
     };
     float_Data @[5] {
      name="rt_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=9;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] 75;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;      };
     };
     float_Data @[6] {
      name="sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] 1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;      };
     };
     float_Data @[7] {
      name="ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;      };
     };
     float_Data @[8] {
      name="fsa_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [34] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;      };
     };
     float_Data @[9] {
      name="Hidden_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 8;8;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=10;
      matrix_col_width=10;
      ar {
       name="ar";
      [8 8 34] 3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;
3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;
3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;
3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;
3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;
3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;
3.2229865e-44;3.2229865e-44;3.2229865e-44;3.2229865e-44;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;
1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;1.4012985e-45;      };
     };
     float_Data @[10] {
      name="Input_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 34] 0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0.94999999;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0;0.94999999;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0.94999999;0.94999999;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0.94999999;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0.94999999;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0.94999999;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0.94999999;0.94999999;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0.94999999;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
      };
     };
     float_Data @[11] {
      name="Target_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 15;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=15;
      matrix_col_width=10;
      ar {
       name="ar";
      [15 1 34] 0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0;0.94999999;0.94999999;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0;0.94999999;0.94999999;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0.94999999;0.94999999;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0;0.94999999;0;0;0;0;
0;0;0;0;0;0;0;0.94999999;0.94999999;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0.94999999;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0.94999999;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0.94999999;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0.94999999;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0.94999999;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0;0.94999999;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0.94999999;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
0.94999999;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0.94999999;0.94999999;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0.94999999;0;0;0;0.94999999;0;0;0;0;
0;0;0;0;0;0;0;0.94999999;0.94999999;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0.94999999;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0.94999999;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [34] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[2] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_247";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_248";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=10;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[6] {
      name="epoch_time_tot";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[7] {
      name="epoch_time_usr";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
     float_Data @[8] {
      name="fsa_err_sum";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
      ar {
       name="ar";
      [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[3] {
    name="EpochOutputDataTest";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_65";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 0;      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_66";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
      };
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 0;      };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 1;      };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 34;      };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 0;      };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=10;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 3.1764705;      };
     };
     float_Data @[6] {
      name="epoch_time_tot";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 0.22;      };
     };
     float_Data @[7] {
      name="epoch_time_usr";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 0.47;      };
     };
     float_Data @[8] {
      name="fsa_err_sum";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
      ar {
       name="ar";
      [1] 0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [1] 0;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp[3] {
   name="ClusterRun";
   el_typ=DataTable;
   el_def=0;
   save_tables=0;
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @[0] {name="DocLink": doc=.programs[0].doc$$: };
   };
   name="LeabraStartup";
   short_nm="Startup";
   tags="Leabra, Startup, Parallel Batch";
   desc="run project in the background command line is: emergent -nogui -ni -p <project name>.proj [epochs=xxx] [batches=xxx] [tag=xxx] | [b_start=xxx] [b_end=xxx] for parallel-batch mode";
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=STARTUP_RUN;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
   };
   objs_vars {
    name="objs_vars";
    el_typ=ProgVar;
    el_def=0;
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     completion_type=;
     object_val=$.networks[0]$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
     reference=0;
     desc="network to operate on -- updates batch counter on network and passes it to train program";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.data.gp[0][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
     reference=0;
     desc="datatable with training patterns -- not used by this program, but passed to train program";
     init_from=NULL;
    };
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="train_prog";
     var_type=T_Object;
     object_type=Program;
     completion_type=;
     object_val=$.programs.gp[0][1]$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
     reference=0;
     desc="set this to point to your train process";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="batch_prog";
     var_type=T_Object;
     object_type=Program;
     completion_type=;
     object_val=.programs.gp[0][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="set this to point to your batch process";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="param_set";
     var_type=T_String;
     string_val=;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="name of saved parameter set to apply at startup";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="tag";
     var_type=T_String;
     string_val="_gui";
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="batch_str";
     var_type=T_String;
     string_val="00";
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch number as a string (leading zeros)";
     init_from=NULL;
    };
    ProgVar @[5] {
     name="log_dir";
     var_type=T_String;
     string_val=;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="log file directory";
     init_from=NULL;
    };
    ProgVar @[6] {
     name="log_file_nm";
     var_type=T_String;
     string_val="/Users/oreilly/svn_sims/leabra/ti/fsa_deep_gui.epc.dat";
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="name of log file";
     init_from=NULL;
    };
    ProgVar @[7] {
     name="batch_start";
     var_type=T_Int;
     int_val=0;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch starting number";
     init_from=NULL;
    };
    ProgVar @[8] {
     name="EpochOutputData";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.data.gp[1][2]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[9] {
     name="TrialOutputData";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.data.gp[1][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[10] {
     name="MyClusterRun";
     var_type=T_Object;
     object_type=ClusterRun;
     completion_type=;
     object_val=.ctrl_panels[1]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[11] {
     name="param_sets";
     var_type=T_Object;
     object_type=ParamSet_Group;
     completion_type=;
     object_val=.active_params$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    ReturnExpr @[0] {
     name="ReturnExpr_return";
     desc=;
     flags=OFF;
     code_string=;
     expr {
      expr=;
     };
    };
    RegisterArgs @[1] {
     name="RegisterArgs_RegisterArgs";
     desc="This is KEY!!! actually processes all args, including those from ProgVarFmArg guys below";
     flags=CAN_REVERT_TO_CODE;
     code_string="Register Args";
    };
    PrintExpr @[2] {
     name="PrintExpr_PrintLoadedproje_ojects0filename";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Loaded project: \" << .projects[0].file_name";
     expr {
      expr="\"Loaded project: \" << .projects[0].file_name";
     };
     debug=0;
    };
    Comment @[3] {
     name="Comment_Stdvariablesinst_upprogramitself";
     desc="= Std variables in startup program itself =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Std variables in startup program itself =";
    };
    ProgVarFmArg @[4] {
     name="ProgVarFmArg_SetVartaginProgr_artupfromArgtag";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:tag in Program:LeabraStartup from Arg:tag";
     prog=.programs[0]$$;
     var_name="tag";
     arg_name="tag";
    };
    ProgVarFmArg @[5] {
     name="ProgVarFmArg_SetVarlogdirinPr_upfromArglogdir";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:log_dir in Program:LeabraStartup from Arg:log_dir";
     prog=$.programs[0]$;
     var_name="log_dir";
     arg_name="log_dir";
    };
    ProgVarFmArg @[6] {
     name="ProgVarFmArg_SetVarparamsetin_fromArgparamset";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:param_set in Program:LeabraStartup from Arg:param_set";
     prog=$.programs[0]$;
     var_name="param_set";
     arg_name="param_set";
    };
    ProgVarFmArg @[7] {
     name="ProgVarFmArg_SetVarmaxepochin_infromArgepochs";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:max_epoch in Program:LeabraTrain from Arg:epochs";
     prog=$.programs.gp[0][1]$;
     var_name="max_epoch";
     arg_name="epochs";
    };
    ProgVarFmArg @[8] {
     name="ProgVarFmArg_SetVarrndinitinP_nfromArgrndinit";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:rnd_init in Program:LeabraTrain from Arg:rnd_init";
     prog=$.programs.gp[0][1]$;
     var_name="rnd_init";
     arg_name="rnd_init";
    };
    ProgVarFmArg @[9] {
     name="ProgVarFmArg_SetVarbatchstart_omArgbatchstart";
     desc="starting batch -- replaces b_start";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="Set Var:batch_start in Program:LeabraBatch from Arg:batch_start";
     prog=$.programs.gp[0][0]$;
     var_name="batch_start";
     arg_name="batch_start";
    };
    ProgVarFmArg @[10] {
     name="ProgVarFmArg_SetVarnbatchesin_fromArgnbatches";
     desc="number of batches to run";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="Set Var:n_batches in Program:LeabraBatch from Arg:n_batches";
     prog=$.programs.gp[0][0]$;
     var_name="n_batches";
     arg_name="n_batches";
    };
    ProgVarFmArg @[11] {
     name="ProgVarFmArg_SetVarsavewtsint_savewtsinterval";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:save_wts_interval in Program:LeabraTrain from Arg:save_wts_interval";
     prog=$.programs.gp[0][1]$;
     var_name="save_wts_interval";
     arg_name="save_wts_interval";
    };
    ProgVarFmArg @[12] {
     name="ProgVarFmArg_SetVarsavefinalw_Argsavefinalwts";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:save_final_wts in Program:LeabraTrain from Arg:save_final_wts";
     prog=$.programs.gp[0][1]$;
     var_name="save_final_wts";
     arg_name="save_final_wts";
    };
    ControlPanelsFmArgs @[13] {
     name="ControlPanelsFmArgs_CtrlPanelFmArgsvarMyClusterRun";
     desc="sets any arg listed in the control panel";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="CtrlPanel Fm Args: var = MyClusterRun ";
     ctrl_panel_var=.programs[0].vars[10]$$;
    };
    If @[14] {
     name="If_ifparamsetnonempty";
     desc="set variables to values stored in a param set";
     flags=CAN_REVERT_TO_CODE;
     code_string="if (param_set.nonempty())";
     cond {
      expr="param_set.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_paramsetsActivat_aramSetparamset";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="param_sets->LoadParamSet(param_set)";
       result_var=NULL;
       obj=.programs[0].vars[11]$$;
       method=ParamSet_Group::ActivateParamSet;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="set_name";
	 required=1;
	 def_val=;
	 prev_expr="param_set";
	 expr {
	  expr="param_set";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="err_not_found";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool ActivateParamSet(taString& set_name, bool err_not_found = true)";
       meth_desc=" find given parameter set by name within this group, and call CopySavedtoActive(true) on that ParamSet if found, otherwise emit an error (if err_not_found) -- one step function for applying named parameter sets in programs";
      };
     };
    };
    Comment @[15] {
     name="Comment_Addyourownvariableshere";
     desc="= Add your own variables here =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Add your own variables here =";
    };
    Comment @[16] {
     name="Comment_Belowsaveslogfil_ndarddatatables";
     desc="= Below saves log files of standard data tables =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Below saves log files of standard data tables =";
    };
    If @[17] {
     name="If_iftaMiscCheckArgByNamebatchstart";
     desc="set tag for starting batch (new code in v 8.0)";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="if (taMisc::CheckArgByName(\"batch_start\"))";
     cond {
      expr="taMisc::CheckArgByName(\"batch_start\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ProgVarFmArg @[0] {
       name="ProgVarFmArg_SetVarbatchstart_omArgbatchstart";
       desc="read in the arg to us too, so we can set file names based on it";
       flags=CAN_REVERT_TO_CODE;
       code_string="Set Var:batch_start in Program:LeabraStartup from Arg:batch_start";
       prog=$.programs[0]$;
       var_name="batch_start";
       arg_name="batch_start";
      };
      MiscCall @[1] {
       name="MiscCall_batchstrtaMiscLe_erosbatchstart2";
       desc="string version with leading zeros";
       flags=CAN_REVERT_TO_CODE;
       code_string="batch_str = taMisc::LeadingZeros(batch_start, 2)";
       result_var=.programs[0].vars[4]$$;
       object_type=taMisc;
       method=taMisc::LeadingZeros;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="num";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="batch_start";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="len";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="2";
	 };
	};
       };
      };
      VarIncr @[2] {
       name="VarIncr_tagbatchstr";
       desc="add to tag for setting log file names";
       flags=CAN_REVERT_TO_CODE;
       code_string="tag += \".\" + batch_str";
       var=.programs[0].vars[3]$$;
       expr {
	expr="\".\" + batch_str";
       };
      };
      If @[3] {
       name="If_ifbatchstart0";
       desc="save startup args: only for first job in parallel batch mode, or this should be 0 otherwise in any case";
       flags=CAN_REVERT_TO_CODE;
       code_string="if (batch_start == 0)";
       cond {
	expr="batch_start == 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_logfilenmEpochOu_e001logdirfalse";
	 desc="save args to file: last arg is to include dmem proc number";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag.before(\".00\",-1), log_dir, false)";
	 result_var=.programs[0].vars[6]$$;
	 obj=.programs[0].vars[8]$$;
	 method=taBase::GetFileNameFmProject;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ext";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\".args\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="tag";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="tag.before(\".00\",-1)";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="subdir";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_dir";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=bool;
	   type="bool";
	   name="dmem_proc_no";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="false";
	   };
	  };
	 };
	 meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
	 meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
	};
	MiscCall @[1] {
	 name="MiscCall_taMiscFullArgStr_ToFilelogfilenm";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="taMisc::FullArgStringToFile(log_file_nm)";
	 result_var=NULL;
	 object_type=taMisc;
	 method=taMisc::FullArgStringToFile;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="fname";
	   required=1;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_file_nm";
	   };
	  };
	 };
	};
       };
      };
     };
    };
    Else @[18] {
     name="Else_If_iftaMiscCheckArgByNamebatchstart";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     cond {
      expr=;
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_logfilenmEpochOu_staglogdirfalse";
       desc="save args to file: last arg is to include dmem proc number";
       flags=CAN_REVERT_TO_CODE;
       code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag, log_dir, false)";
       result_var=$.programs[0].vars[6]$;
       obj=$.programs[0].vars[8]$;
       method=taBase::GetFileNameFmProject;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="ext";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\".args\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="tag";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="tag";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="subdir";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_dir";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_no";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
       meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
      };
      MiscCall @[1] {
       name="MiscCall_taMiscFullArgStr_ToFilelogfilenm";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::FullArgStringToFile(log_file_nm)";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::FullArgStringToFile;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_file_nm";
	 };
	};
       };
      };
     };
    };
    MiscCall @[19] {
     name="MiscCall_taMiscReportUnusedArgstrue";
     desc="report any args that didn't get used!";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="taMisc::ReportUnusedArgs(true)";
     result_var=NULL;
     object_type=taMisc;
     method=taMisc::ReportUnusedArgs;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="err";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
    };
    Comment @[20] {
     name="Comment_Saveepochlogonbydefault";
     desc="== Save epoch log -- on by default ==";
     flags=CAN_REVERT_TO_CODE;
     code_string="// == Save epoch log -- on by default ==";
    };
    MethodCall @[21] {
     name="MethodCall_logfilenmEpochOu_ttaglogdirfalse";
     desc="last arg is to include dmem proc number";
     flags=CAN_REVERT_TO_CODE;
     code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".epc.dat\", tag, log_dir, false)";
     result_var=$.programs[0].vars[6]$;
     obj=$.programs[0].vars[8]$;
     method=taBase::GetFileNameFmProject;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="ext";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\".epc.dat\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="tag";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="tag";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="subdir";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_dir";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_no";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
     meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
    };
    MethodCall @[22] {
     name="MethodCall_EpochOutputDataS_filenmfalsetrue";
     desc="last arg is to restrict log to dmem_proc = 0";
     flags=CAN_REVERT_TO_CODE;
     code_string="EpochOutputData->SaveDataLog(log_file_nm, false, true)";
     result_var=NULL;
     obj=$.programs[0].vars[8]$;
     method=DataTable::SaveDataLog;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_file_nm";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="append";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_0";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
     meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
    };
    PrintVar @[23] {
     name="PrintVar_PrintSavingepoch_datatologfilenm";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"Saving epoch log data to:\" log_file_nm";
     message="Saving epoch log data to:";
     print_var=$.programs[0].vars[6]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    Comment @[24] {
     name="Comment_SavetriallogOFFbydefault";
     desc="== Save trial log -- OFF by default ==";
     flags=CAN_REVERT_TO_CODE;
     code_string="// == Save trial log -- OFF by default ==";
    };
    MethodCall @[25] {
     name="MethodCall_logfilenmTrialOu_attaglogdirtrue";
     desc="last arg is to include dmem proc number";
     flags=OFF|CAN_REVERT_TO_CODE;
     code_string="log_file_nm = TrialOutputData->GetFileNameFmProject(\".trl.dat\", tag, log_dir, true)";
     result_var=$.programs[0].vars[6]$;
     obj=.programs[0].vars[9]$$;
     method=taBase::GetFileNameFmProject;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="ext";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\".trl.dat\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="tag";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="tag";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="subdir";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_dir";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_no";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
     meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
    };
    MethodCall @[26] {
     name="MethodCall_TrialOutputDataS_ilenmfalsefalse";
     desc="last arg is to restrict log to dmem_proc = 0";
     flags=OFF|CAN_REVERT_TO_CODE;
     code_string="TrialOutputData->SaveDataLog(log_file_nm, false, false)";
     result_var=NULL;
     obj=$.programs[0].vars[9]$;
     method=DataTable::SaveDataLog;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="log_file_nm";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="append";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_0";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
     meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
    };
    PrintVar @[27] {
     name="PrintVar_PrintSavingtrial_datatologfilenm";
     desc=;
     flags=OFF|CAN_REVERT_TO_CODE;
     code_string="Print  \"Saving trial log data to:\" log_file_nm";
     message="Saving trial log data to:";
     print_var=$.programs[0].vars[6]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    OtherProgramVar @[28] {
     name="OtherProgramVar_VarsToprogramSav_tagvar2var3var4";
     desc="propagate the tag";
     flags=CAN_REVERT_TO_CODE;
     code_string="Vars To:  program=SaveWeights set=to  var_1=tag  var_2=?  var_3=?  var_4=? ";
     other_prog=.programs.gp[0][9]$$;
     set_other=1;
     var_1=$.programs[0].vars[3]$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    PrintExpr @[29] {
     name="PrintExpr_PrintRunningbatchprogname";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Running: \" << batch_prog.name";
     expr {
      expr="\"Running: \" << batch_prog.name";
     };
     debug=0;
    };
    ProgramCall @[30] {
     name="ProgramCall_LeabraBatchnetworkinputdata";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LeabraBatch(network, input_data)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="input_data";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="input_data";
       };
      };
     };
     target=$.programs.gp[0][0]$;
     targ_ld_init="*LeabraBatch*";
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @[0] {name="DocLink": doc=.programs[1].doc$$: };
   };
   name="EpochsToTrainCR";
   short_nm="EpchTTr";
   tags="Data, Analysis, Epoch, Training, ClusterRun";
   desc="performs various stats on epochs to train to criterion, across multiple batches, including an additional err threshold that can be different than the training stopping criterion, and also the minimum error value achieved across batches";
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=NO_STOP_STEP;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=Relation;
    el_def=0;
    Relation @[0] {name="rel": rel=EQUAL: val=0: val_string="": use_var=0: var=NULL: };
    DataTable @[1] {
     name="AllData";
     desc=;
     data {
      name="data";
      el_typ=int_Data;
      el_def=0;
      int_Data @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="batch";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=8;
       matrix_col_width=10;
      };
      int_Data @[1] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="epoch";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=8;
       matrix_col_width=10;
      };
      float_Data @[2] {
       name="avg_sse";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=8;
       matrix_col_width=10;
      };
      float_Data @[3] {
       name="cnt_err";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=8;
       matrix_col_width=10;
      };
      float_Data @[4] {
       name="avg_ext_rew";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=11;
       matrix_col_width=10;
      };
      float_Data @[5] {
       name="avg_cycles";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=10;
       matrix_col_width=10;
      };
      float_Data @[6] {
       name="epoch_time_tot";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=14;
       matrix_col_width=10;
      };
      float_Data @[7] {
       name="epoch_time_usr";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=14;
       matrix_col_width=10;
      };
      float_Data @[8] {
       name="fsa_err_sum";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=11;
       matrix_col_width=10;
      };
      String_Data @[9] {
       name="tag";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[10] {
       name="tag_svn";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[11] {
       name="tag_job";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[12] {
       name="notes";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[13] {
       name="label";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[14] {
       name="params";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      float_Data @[15] {
       name="lrate";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=8;
       matrix_col_width=10;
      };
      float_Data @[16] {
       name="td_wt_scale_rel";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=15;
       matrix_col_width=10;
      };
      float_Data @[17] {
       name="n_batches";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=9;
       matrix_col_width=10;
      };
      float_Data @[18] {
       name="batch_start";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=11;
       matrix_col_width=10;
      };
      float_Data @[19] {
       name="tictxt_wt_scale_rel";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=19;
       matrix_col_width=10;
      };
      float_Data @[20] {
       name="act_avg_ml_in_m";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=15;
       matrix_col_width=10;
      };
      float_Data @[21] {
       name="act_avg_ml_tau";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=14;
       matrix_col_width=10;
      };
      float_Data @[22] {
       name="decay_trial";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=11;
       matrix_col_width=10;
      };
      float_Data @[23] {
       name="del_inhib_prv_trl";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=17;
       matrix_col_width=10;
      };
      float_Data @[24] {
       name="lay_inhib_gi";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=12;
       matrix_col_width=10;
      };
     };
     data_flags=AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     row_height=1;
     max_col_width=50;
     keygen 4 0=0;
     last_sort_spec {
      name="last_sort_spec";
      ops {
       name="ops";
       el_typ=DataSortEl;
       el_def=0;
      };
     };
     row_with_hilite=-1;
    };
    DataTable @[2] {
     name="ByBatchData";
     desc=;
     data {
      name="data";
      el_typ=int_Data;
      el_def=0;
      String_Data @[0] {
       name="tag_svn_group";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      int_Data @[1] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_411";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="batch_group";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=11;
       matrix_col_width=10;
      };
      float_Data @[2] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_413";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="epoch_last";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=10;
       matrix_col_width=10;
      };
      float_Data @[3] {
       name="fsa_err_sum_find_first";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=22;
       matrix_col_width=10;
      };
      float_Data @[4] {
       name="fsa_err_sum_min";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=15;
       matrix_col_width=10;
      };
      String_Data @[5] {
       name="label_last";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[6] {
       name="notes_last";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[7] {
       name="params_last";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
     };
     data_flags=AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     row_height=1;
     max_col_width=50;
     keygen 4 0=0;
     last_sort_spec {
      name="last_sort_spec";
      ops {
       name="ops";
       el_typ=DataSortEl;
       el_def=0;
      };
     };
     row_with_hilite=-1;
    };
    DataTable @[3] {
     name="ByTagStats";
     desc=;
     data {
      name="data";
      el_typ=int_Data;
      el_def=0;
      String_Data @[0] {
       name="tag_svn_group_group";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=19;
       matrix_col_width=10;
      };
      String_Data @[1] {
       name="label_last_last";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[2] {
       name="notes_last_last";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      String_Data @[3] {
       name="params_last_last";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=16;
       matrix_col_width=10;
      };
      float_Data @[4] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_394";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="N";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=8;
       matrix_col_width=10;
      };
      float_Data @[5] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_395";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="epoch_last_min";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=14;
       matrix_col_width=10;
      };
      float_Data @[6] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_396";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="epoch_last_max";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=14;
       matrix_col_width=10;
      };
      float_Data @[7] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_397";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="epoch_last_n_at_max";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=19;
       matrix_col_width=10;
      };
      float_Data @[8] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_398";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="epoch_last_mean";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=15;
       matrix_col_width=10;
      };
      float_Data @[9] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_399";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
       };
       name="epoch_last_sem";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=14;
       matrix_col_width=10;
      };
      float_Data @[10] {
       name="fsa_err_sum_find_first_min";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=26;
       matrix_col_width=10;
      };
      float_Data @[11] {
       name="fsa_err_sum_find_first_max";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=26;
       matrix_col_width=10;
      };
      float_Data @[12] {
       name="fsa_err_sum_find_first_n_at_max";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=31;
       matrix_col_width=10;
      };
      float_Data @[13] {
       name="fsa_err_sum_find_first_mean";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=27;
       matrix_col_width=10;
      };
      float_Data @[14] {
       name="fsa_err_sum_find_first_sem";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=26;
       matrix_col_width=10;
      };
      float_Data @[15] {
       name="fsa_err_sum_min_min";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=19;
       matrix_col_width=10;
      };
      float_Data @[16] {
       name="fsa_err_sum_min_max";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=19;
       matrix_col_width=10;
      };
      float_Data @[17] {
       name="fsa_err_sum_min_mean";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=20;
       matrix_col_width=10;
      };
      float_Data @[18] {
       name="fsa_err_sum_min_sem";
       col_flags=SAVE_DATA|AUTO_WIDTH;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=19;
       matrix_col_width=10;
      };
     };
     data_flags=AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     row_height=1;
     max_col_width=50;
     keygen 4 0=0;
     last_sort_spec {
      name="last_sort_spec";
      ops {
       name="ops";
       el_typ=DataSortEl;
       el_def=0;
      };
     };
     row_with_hilite=-1;
    };
   };
   objs_vars {
    name="objs_vars";
    el_typ=ProgVar;
    el_def=0;
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="ClusterRunData";
     var_type=T_Object;
     object_type=DataTable_Group;
     completion_type=;
     object_val=.data.gp[3]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="err_thresh";
     var_type=T_Int;
     int_val=5;
     completion_type=;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="alternative error threshold to use";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="rel";
     var_type=T_Object;
     object_type=Relation;
     completion_type=;
     object_val=.programs[1].objs[0]$$;
     object_scope=NULL;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="AllData";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.programs[1].objs[1]$$;
     object_scope=NULL;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="ByBatchData";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.programs[1].objs[2]$$;
     object_scope=NULL;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="ByTagStats";
     var_type=T_Object;
     object_type=DataTable;
     completion_type=;
     object_val=.programs[1].objs[3]$$;
     object_scope=NULL;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[6] {
     name="epoch_last_max";
     var_type=T_Real;
     real_val=99;
     completion_type=;
     object_scope=NULL;
     flags=SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[7] {
     name="find_first_max";
     var_type=T_Real;
     real_val=16;
     completion_type=;
     object_scope=NULL;
     flags=SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     name="LocalVars_LocalVars2vars";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="dt";
       var_type=T_Object;
       object_type=DataTable;
       completion_type=;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="max_idx";
       var_type=T_Int;
       int_val=42;
       completion_type=;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     name="MethodCall_AllDataResetData";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="AllData->ResetData()";
     result_var=NULL;
     obj=.programs[1].vars[3]$$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    ForeachLoop @[2] {
     name="ForeachLoop_foreachdtinClusterRunData";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="foreach(dt in ClusterRunData)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_ifAllDatarows0";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (AllData.rows == 0)";
       cond {
	expr="AllData.rows == 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_AllDataCopyFromdt";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="AllData->CopyFrom(dt)";
	 result_var=NULL;
	 obj=$.programs[1].vars[3]$;
	 method=taBase::CopyFrom;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taBase_ptr;
	   type="taBase*";
	   name="cpy_from";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="dt";
	   };
	  };
	 };
	 meth_sig="bool CopyFrom(taBase* cpy_from)";
	 meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
	};
       };
      };
      Else @[1] {
       name="Else_If_ifAllDatarows0";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       cond {
	expr=;
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	DataProcCall @[0] {
	 name="DataProcCall_taDataProcCopyCo_olDataAllDatadt";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="taDataProc::CopyCommonColData(AllData, dt)";
	 result_var=NULL;
	 object_type=taDataProc;
	 method=taDataProc::CopyCommonColData;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="dest";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="AllData";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="src";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="dt";
	   };
	  };
	 };
	};
       };
      };
     };
     el_var=.programs[1].prog_code[0].local_vars[0]$$;
     in {
      expr="ClusterRunData";
     };
    };
    DataGroupProg @[3] {
     name="DataGroupProg_Groupfromsrctabl_ableByBatchData";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Group from:  src table = AllData dest table = ByBatchData";
     src_table=;
     dest_table=;
     src_data_var=$.programs[1].vars[3]$;
     dest_data_var=.programs[1].vars[4]$$;
     group_spec {
      name="group_spec";
      ops {
       name="ops";
       el_typ=DataGroupEl;
       el_def=0;
       DataGroupEl @[0] {
	col_name="tag_svn";
	name="tag_svn_GROUP_0";
	agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[1] {
	col_name="batch";
	name="batch_GROUP_1";
	agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[2] {
	col_name="epoch";
	name="epoch_LAST_2";
	agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[3] {
	col_name="fsa_err_sum";
	name="fsa_err_sum_FIND_FIRST_3";
	agg {name="agg": op=FIND_FIRST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=1: var=.programs[1].vars[1]$$: }: };
       };
       DataGroupEl @[4] {
	col_name="fsa_err_sum";
	name="fsa_err_sum_MIN_4";
	agg {name="agg": op=MIN: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[5] {
	col_name="label";
	name="label_LAST_5";
	agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[6] {
	col_name="notes";
	name="notes_LAST_6";
	agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[7] {
	col_name="params";
	name="params_LAST_7";
	agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
      };
      append_agg_name=1;
     };
    };
    MemberMethodCall @[4] {
     name="MemberMethodCall_ByBatchDatadatae_petaBaseVTFLOAT";
     desc="change type to float, to enable subsequent analysis operations";
     flags=CAN_REVERT_TO_CODE;
     code_string="ByBatchData.data.epoch_last.ChangeColType(taBase::VT_FLOAT)";
     obj=$.programs[1].vars[4]$;
     path="data.epoch_last";
     result_var=NULL;
     method=DataCol::ChangeColType;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase::ValType;
       type="taBase::ValType";
       name="new_type";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="taBase::VT_FLOAT";
       };
      };
     };
     meth_sig="void ChangeColType(taBase::ValType new_type)";
     meth_desc=" change the type of the data in this col, without loss of data";
    };
    MathCall @[5] {
     name="MathCall_epochlastmaxtaMa_ochlastarmaxidx";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="epoch_last_max = taMath_float::vec_max(ByBatchData.data.epoch_last.ar, max_idx)";
     result_var=.programs[1].vars[6]$$;
     object_type=taMath_float;
     method=taMath_float::vec_max;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="vec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="ByBatchData.data.epoch_last.ar";
       };
      };
      ProgArg @[1] {
       arg_type=int_ref;
       type="int&";
       name="idx";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="max_idx";
       };
      };
     };
    };
    MathCall @[6] {
     name="MathCall_findfirstmaxtaMa_ndfirstarmaxidx";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="find_first_max = taMath_float::vec_max(ByBatchData.data.fsa_err_sum_find_first.ar, max_idx)";
     result_var=.programs[1].vars[7]$$;
     object_type=taMath_float;
     method=taMath_float::vec_max;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="vec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="ByBatchData.data.fsa_err_sum_find_first.ar";
       };
      };
      ProgArg @[1] {
       arg_type=int_ref;
       type="int&";
       name="idx";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="max_idx";
       };
      };
     };
    };
    DataGroupProg @[7] {
     name="DataGroupProg_Groupfromsrctabl_tableByTagStats";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Group from:  src table = ByBatchData dest table = ByTagStats";
     src_table=;
     dest_table=;
     src_data_var=$.programs[1].vars[4]$;
     dest_data_var=.programs[1].vars[5]$$;
     group_spec {
      name="group_spec";
      ops {
       name="ops";
       el_typ=DataGroupEl;
       el_def=0;
       DataGroupEl @[0] {
	col_name="tag_svn_group";
	name="tag_svn_group_GROUP_0";
	agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[1] {
	col_name="label_last";
	name="label_last_LAST_1";
	agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[2] {
	col_name="notes_last";
	name="notes_last_LAST_2";
	agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[3] {
	col_name="params_last";
	name="params_last_LAST_3";
	agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[4] {
	col_name="epoch_last";
	name="epoch_last_N_4";
	agg {name="agg": op=N: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[5] {
	col_name="epoch_last";
	name="epoch_last_MIN_5";
	agg {name="agg": op=MIN: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[6] {
	col_name="epoch_last";
	name="epoch_last_MAX_6";
	agg {name="agg": op=MAX: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[7] {
	col_name="epoch_last";
	name="epoch_last_COUNT_7";
	agg {name="agg": op=COUNT: rel={name="rel": rel=EQUAL: val=0: val_string="": use_var=1: var=$.programs[1].vars[6]$: }: };
       };
       DataGroupEl @[8] {
	col_name="epoch_last";
	name="epoch_last_MEAN_8";
	agg {name="agg": op=MEAN: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[9] {
	col_name="epoch_last";
	name="epoch_last_SEM_9";
	agg {name="agg": op=SEM: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[10] {
	col_name="fsa_err_sum_find_first";
	name="fsa_err_sum_find_first_MIN_10";
	agg {name="agg": op=MIN: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=1: var=$.programs[1].vars[1]$: }: };
       };
       DataGroupEl @[11] {
	col_name="fsa_err_sum_find_first";
	name="fsa_err_sum_find_first_MAX_11";
	agg {name="agg": op=MAX: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=1: var=$.programs[1].vars[1]$: }: };
       };
       DataGroupEl @[12] {
	col_name="fsa_err_sum_find_first";
	name="fsa_err_sum_find_first_COUNT_12";
	agg {name="agg": op=COUNT: rel={name="rel": rel=EQUAL: val=0: val_string="": use_var=1: var=$.programs[1].vars[7]$: }: };
       };
       DataGroupEl @[13] {
	col_name="fsa_err_sum_find_first";
	name="fsa_err_sum_find_first_MEAN_13";
	agg {name="agg": op=MEAN: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=1: var=$.programs[1].vars[1]$: }: };
       };
       DataGroupEl @[14] {
	col_name="fsa_err_sum_find_first";
	name="fsa_err_sum_find_first_SEM_14";
	agg {name="agg": op=SEM: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=1: var=$.programs[1].vars[1]$: }: };
       };
       DataGroupEl @[15] {
	col_name="fsa_err_sum_min";
	name="fsa_err_sum_min_MIN_15";
	agg {name="agg": op=MIN: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[16] {
	col_name="fsa_err_sum_min";
	name="fsa_err_sum_min_MAX_16";
	agg {name="agg": op=MAX: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[17] {
	col_name="fsa_err_sum_min";
	name="fsa_err_sum_min_MEAN_17";
	agg {name="agg": op=MEAN: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
       DataGroupEl @[18] {
	col_name="fsa_err_sum_min";
	name="fsa_err_sum_min_SEM_18";
	agg {name="agg": op=SEM: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
       };
      };
      append_agg_name=1;
     };
    };
    MemberAssign @[8] {
     name="MemberAssign_ByTagStatsdataep_epochlastnatmax";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ByTagStats.data.epoch_last_count.name = \"epoch_last_n_at_max\"";
     obj=$.programs[1].vars[5]$;
     path="data.epoch_last_count.name";
     expr {
      expr="\"epoch_last_n_at_max\"";
     };
     update_after=0;
    };
    MemberAssign @[9] {
     name="MemberAssign_ByTagStatsdatafs_findfirstnatmax";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ByTagStats.data.fsa_err_sum_find_first_count.name = \"fsa_err_sum_find_first_n_at_max\"";
     obj=$.programs[1].vars[5]$;
     path="data.fsa_err_sum_find_first_count.name";
     expr {
      expr="\"fsa_err_sum_find_first_n_at_max\"";
     };
     update_after=0;
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][0].doc$$: };
    };
    name="LeabraBatch";
    short_nm="Batch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="batch_start";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch number to start on";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="n_batches";
      var_type=T_Int;
      int_val=10;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="number of batches to run";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitbatch";
      desc="initializes local batch counter and batch field on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: batch";
      network_var=.programs.gp[0][0].args[0]$$;
      local_ctr_var=.programs.gp[0][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars1vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="i";
	var_type=T_Int;
	int_val=0;
	completion_type=;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     AssignExpr @[1] {
      name="AssignExpr_batchbatchstart";
      desc="start at the start";
      flags=CAN_REVERT_TO_CODE;
      code_string="batch = batch_start";
      result_var=$.programs.gp[0][0].vars[0]$;
      expr {
       expr="batch_start";
      };
     };
     MemberAssign @[2] {
      name="MemberAssign_networkbatchbatch";
      desc="update network";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.batch = batch";
      obj=$.programs.gp[0][0].args[0]$;
      path="batch";
      expr {
       expr="batch";
      };
      update_after=0;
     };
     ForLoop @[3] {
      name="ForLoop_fori0inbatchesi";
      desc="main loop over training runs";
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i=0; i<n_batches; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraTrainnetworkinputdatatrue";
	desc="run the training program -- sets the network and input_data args";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraTrain(network, input_data, true)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="true";
	  };
	 };
	};
	target=$.programs.gp[0][1]$;
	targ_ld_init="*LeabraTrain*";
       };
       NetCounterIncr @[1] {
	name="NetCounterIncr_NetCounterIncrbatch";
	desc="increment the local batch counter and copy to network";
	flags=CAN_REVERT_TO_CODE;
	code_string="Net Counter Incr: batch";
	network_var=$.programs.gp[0][0].args[0]$;
	local_ctr_var=$.programs.gp[0][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      init {
       expr="i=0";
      };
      test {
       expr="i<n_batches";
      };
      iter {
       expr="i++";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][1].doc$$: };
    };
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Train, RndSeedList";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task.  Also has a list of random seeds that are tied to the network batch counter, providing consistent runs regardless of what happens in the training of each network, or where it is run (e.g., on different processors)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=RndSeed;
     el_def=0;
     RndSeed_List @[0] {
      name="rnd_seeds";
      seeds {
       name="seeds";
       el_typ=RndSeed;
       el_def=0;
       RndSeed @[0] {
	name="RndSeed_1";
	rnd_seed=1952698542;
       };
       RndSeed @[1] {
	name="RndSeed_2";
	rnd_seed=1952698543;
       };
       RndSeed @[2] {
	name="RndSeed_3";
	rnd_seed=1952698544;
       };
       RndSeed @[3] {
	name="RndSeed_4";
	rnd_seed=1952698545;
       };
       RndSeed @[4] {
	name="RndSeed_5";
	rnd_seed=1952698546;
       };
       RndSeed @[5] {
	name="RndSeed_6";
	rnd_seed=1952698547;
       };
       RndSeed @[6] {
	name="RndSeed_7";
	rnd_seed=1952698548;
       };
       RndSeed @[7] {
	name="RndSeed_8";
	rnd_seed=1952698549;
       };
       RndSeed @[8] {
	name="RndSeed_9";
	rnd_seed=1952698550;
       };
       RndSeed @[9] {
	name="RndSeed_10";
	rnd_seed=1952698551;
       };
       RndSeed @[10] {
	name="RndSeed_11";
	rnd_seed=1952698552;
       };
       RndSeed @[11] {
	name="RndSeed_12";
	rnd_seed=1952698553;
       };
       RndSeed @[12] {
	name="RndSeed_13";
	rnd_seed=1952698554;
       };
       RndSeed @[13] {
	name="RndSeed_14";
	rnd_seed=1952698555;
       };
       RndSeed @[14] {
	name="RndSeed_15";
	rnd_seed=1952698556;
       };
       RndSeed @[15] {
	name="RndSeed_16";
	rnd_seed=1952698557;
       };
       RndSeed @[16] {
	name="RndSeed_17";
	rnd_seed=1952698558;
       };
       RndSeed @[17] {
	name="RndSeed_18";
	rnd_seed=1952698559;
       };
       RndSeed @[18] {
	name="RndSeed_19";
	rnd_seed=1952698560;
       };
       RndSeed @[19] {
	name="RndSeed_20";
	rnd_seed=1952698561;
       };
       RndSeed @[20] {
	name="RndSeed_21";
	rnd_seed=1952698562;
       };
       RndSeed @[21] {
	name="RndSeed_22";
	rnd_seed=1952698563;
       };
       RndSeed @[22] {
	name="RndSeed_23";
	rnd_seed=1952698564;
       };
       RndSeed @[23] {
	name="RndSeed_24";
	rnd_seed=1952698565;
       };
       RndSeed @[24] {
	name="RndSeed_25";
	rnd_seed=1952698566;
       };
      };
     };
     RndSeed @[1] {
      name="rnd_seed";
      rnd_seed=1879640322;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="rnd_seeds";
      var_type=T_Object;
      object_type=RndSeed_List;
      completion_type=;
      object_val=.programs.gp[0][1].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      completion_type=;
      object_val=.programs.gp[0][1].objs[1]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
       DynEnumItem @[2] {
	name="BATCH_SEEDS";
	value=2;
	desc="use a fixed list of random seeds with the current batch number selecting the seed to use -- provides a consistent set of initial conditions for each batch regardless..";
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=100;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      hard_enum_type=Network::TrainMode;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      completion_type=;
      object_scope=NULL;
      dyn_enum_val {
       user_data_=NULL;
       enum_type=.programs.gp[0][1].types[0]$$;
       value=2;
      };
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion for training, in terms of count of trials with errors in the epoch (nework cnt_err)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="n_under_thr";
      var_type=T_Int;
      int_val=3;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="number of times network needs to be under stopcrit threshold to actually stop";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="save_final_wts";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="save the network's weights at the end of training?  ";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="save_wts_interval";
      var_type=T_Int;
      int_val=-1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="save the weights every this many epochs, if number is >= 1 (otherwise do not save weights)";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="n_under_cnt";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current under threshold counter";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      completion_type=;
      object_val=.networks[0].train_time$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @[0] {
      name="GetRandomSeed";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="GetRandomSeed() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars0vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       Switch @[1] {
	name="Switch_switchrndinit";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="switch(rnd_init)";
	switch_var=.programs.gp[0][1].vars[3]$$;
	cases {
	 name="cases";
	 el_typ=CaseBlock;
	 el_def=0;
	 CaseBlock @[0] {
	  name="CaseBlock_caseOLDSEED";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: OLD_SEED";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_rndseedOldSeed";
	    desc="restore previous random seed (all runs produce same results) -- click on rnd_seed object to generate a new seed to use for this if you want";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="rnd_seed->OldSeed()";
	    result_var=NULL;
	    obj=.programs.gp[0][1].objs_vars[1]$$;
	    method=RndSeed::OldSeed;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void OldSeed()";
	    meth_desc=" restore current seed to random num generator";
	   };
	  };
	  case_val {
	   expr="OLD_SEED";
	  };
	  is_default=0;
	 };
	 CaseBlock @[1] {
	  name="CaseBlock_caseNEWSEED";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: NEW_SEED";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_rndseedNewSeed";
	    desc="new random numbers each time";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="rnd_seed->NewSeed()";
	    result_var=NULL;
	    obj=$.programs.gp[0][1].objs_vars[1]$;
	    method=RndSeed::NewSeed;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void NewSeed()";
	    meth_desc=" set the seed to a new random value (based on time and process id)";
	   };
	  };
	  case_val {
	   expr="NEW_SEED";
	  };
	  is_default=0;
	 };
	 CaseBlock @[2] {
	  name="CaseBlock_caseBATCHSEEDS";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: BATCH_SEEDS";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_rndseedsUseSeedn_dseedsseedssize";
	    desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="rnd_seeds->UseSeed(network.batch % rnd_seeds.seeds.size)";
	    result_var=NULL;
	    obj=.programs.gp[0][1].objs_vars[0]$$;
	    method=RndSeed_List::UseSeed;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=int;
	      type="int";
	      name="idx";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="network.batch % rnd_seeds.seeds.size";
	      };
	     };
	    };
	    meth_sig="void UseSeed(int idx)";
	    meth_desc=" use seed at given index in the list (does OldSeed on it); wraps around (modulus) if idx is > list size (issues warning)";
	   };
	  };
	  case_val {
	   expr="BATCH_SEEDS";
	  };
	  is_default=0;
	 };
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MemberAssign @[0] {
      name="MemberAssign_networktrainmodeNetworkTRAIN";
      desc="set to testing mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TRAIN";
      obj=$.programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TRAIN";
      };
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_nopromptsfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="no_prompts = false";
      result_var=.programs.gp[0][1].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[2] {
      name="MethodCall_networkCheckConfigfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[0][1].args[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     AssignExpr @[3] {
      name="AssignExpr_traintimernetworktraintime";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer = network.train_time";
      result_var=.programs.gp[0][1].vars[9]$$;
      expr {
       expr="network.train_time";
      };
     };
     AssignExpr @[4] {
      name="AssignExpr_nundercnt0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="n_under_cnt = 0";
      result_var=.programs.gp[0][1].vars[8]$$;
      expr {
       expr="0";
      };
     };
     FunctionCall @[5] {
      name="FunctionCall_GetRandomSeed";
      desc="initialize random seed";
      flags=CAN_REVERT_TO_CODE;
      code_string="GetRandomSeed()";
      result_var=NULL;
      fun=.programs.gp[0][1].functions[0]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WtInitPrompt @[6] {
      name="WtInitPrompt_ifguiDoyouwantto_eNetworkWeights";
      desc="don't initialize weights without checking";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (gui && \"Do you want to Initialize Network Weights\")";
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name="yes_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkBuild";
	desc="need to have built network by now in any case, so do it here to make double sure -- prevents errs when loading project with startup program";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Build()";
	result_var=NULL;
	obj=$.programs.gp[0][1].args[0]$;
	method=Network::Build;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Build()";
	meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
       };
       MethodCall @[1] {
	name="MethodCall_networkInitWeights";
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Init_Weights()";
	result_var=NULL;
	obj=$.programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Init_Weights()";
	meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
       };
       PrintExpr @[2] {
	name="PrintExpr_Printnetworkname_ghtsInitialized";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print network.name << \" Weights Initialized\"";
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	debug=0;
       };
      };
     };
     AssignExpr @[7] {
      name="AssignExpr_epochnetworkepoch";
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch = network.epoch";
      result_var=.programs.gp[0][1].vars[1]$$;
      expr {
       expr="network.epoch";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MemberAssign @[0] {
      name="MemberAssign_networktrainmodeNetworkTRAIN";
      desc="set to testing mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TRAIN";
      obj=$.programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TRAIN";
      };
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_traintimernetworktraintime";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer = network.train_time";
      result_var=$.programs.gp[0][1].vars[9]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[2] {
      name="MethodCall_traintimerStartTimertrue";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer->StartTimer(true)";
      result_var=NULL;
      obj=$.programs.gp[0][1].vars[9]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     AssignExpr @[3] {
      name="AssignExpr_nundercnt0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="n_under_cnt = 0";
      result_var=$.programs.gp[0][1].vars[8]$;
      expr {
       expr="0";
      };
     };
     MemberAssign @[4] {
      name="MemberAssign_networktrainmodetrainmode";
      desc="set network's training mode to our local value";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.train_mode = train_mode";
      obj=$.programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     FunctionCall @[5] {
      name="FunctionCall_GetRandomSeed";
      desc="initialize random seed";
      flags=CAN_REVERT_TO_CODE;
      code_string="GetRandomSeed()";
      result_var=NULL;
      fun=$.programs.gp[0][1].functions[0]$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[6] {
      name="If_ifnoprompts";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (no_prompts)";
      cond {
       expr="no_prompts";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkInitWeights";
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Init_Weights()";
	result_var=NULL;
	obj=$.programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Init_Weights()";
	meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
       };
       PrintExpr @[1] {
	name="PrintExpr_Printnetworkname_ghtsInitialized";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print network.name << \" Weights Initialized\"";
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	debug=0;
       };
      };
     };
     AssignExpr @[7] {
      name="AssignExpr_epochnetworkepoch";
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch = network.epoch";
      result_var=$.programs.gp[0][1].vars[1]$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[8] {
      name="WhileLoop_whileepochmaxepoch";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="while (epoch < max_epoch)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraEpochnetworkinputdata";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraEpoch(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.programs.gp[0][2]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	name="NetCounterIncr_NetCounterIncrepoch";
	desc="increment the epoch counter";
	flags=CAN_REVERT_TO_CODE;
	code_string="Net Counter Incr: epoch";
	network_var=$.programs.gp[0][1].args[0]$;
	local_ctr_var=$.programs.gp[0][1].vars[1]$;
	counter=Network::epoch;
	update_after=0;
       };
       If @[2] {
	name="If_ifnetworkcnterrerrstopcrit";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (network.cnt_err <= err_stopcrit)";
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 VarIncr @[0] {
	  name="VarIncr_nundercnt1";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="n_under_cnt += 1";
	  var=$.programs.gp[0][1].vars[8]$;
	  expr {
	   expr="1";
	  };
	 };
	 IfBreak @[1] {
	  name="IfBreak_ifnundercntnunderthrbreak";
	  desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here too)";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if(n_under_cnt >=  n_under_thr) break";
	  cond {
	   expr="n_under_cnt >=  n_under_thr";
	  };
	 };
	};
       };
       Else @[3] {
	name="Else_If_ifnetworkcnterrerrstopcrit";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="else";
	cond {
	 expr=;
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  name="AssignExpr_nundercnt0";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="n_under_cnt = 0";
	  result_var=$.programs.gp[0][1].vars[8]$;
	  expr {
	   expr="0";
	  };
	 };
	};
       };
       If @[4] {
	name="If_ifsavewtsinterval1";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (save_wts_interval >= 1)";
	cond {
	 expr="save_wts_interval >= 1";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 If @[0] {
	  name="If_ifepochsavewtsinterval0";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (epoch % save_wts_interval == 0)";
	  cond {
	   expr="epoch % save_wts_interval == 0";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ProgramCall @[0] {
	    name="ProgramCall_SaveWeightsnetwork";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="SaveWeights(network)";
	    prog_args {
	     name="prog_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=Network;
	      type="LeabraNetwork*";
	      name="network";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="network";
	      };
	     };
	    };
	    target=$.programs.gp[0][9]$;
	    targ_ld_init="*SaveWeights*";
	   };
	  };
	 };
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     If @[9] {
      name="If_ifsavefinalwts";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (save_final_wts)";
      cond {
       expr="save_final_wts";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_SaveWeightsnetwork";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeights(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Network;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[0][9]$;
	targ_ld_init="*SaveWeights*";
       };
      };
     };
     MethodCall @[10] {
      name="MethodCall_traintimerEndTimer";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="train_timer->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[0][1].vars[9]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
    };
    step_prog=.programs.gp[0][3]$$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][2].doc$$: };
    };
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=2;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      hard_enum_type=DataLoop::Order;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="step_on_err";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="when you step at the Epoch level, this will automatically step through to the next point at which an error was made -- you can use the netview history to replay what happend";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      completion_type=;
      object_val=.networks[0].epoch_time$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="n_epochs_per_env";
      var_type=T_Int;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[7] {
      name="n_seqs_per_epcoh";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[8] {
      name="group_order";
      var_type=T_HardEnum;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      hard_enum_type=DataLoop::Order;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[9] {
      name="group_index";
      var_type=T_Int;
      int_val=23;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=.programs.gp[0][2].args[0]$$;
      local_ctr_var=.programs.gp[0][2].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[0][2].vars[4]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=$.programs.gp[0][2].args[0]$;
      local_ctr_var=$.programs.gp[0][2].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[0][2].vars[4]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      name="MethodCall_epochtimerStartTimertrue";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->StartTimer(true)";
      result_var=NULL;
      obj=$.programs.gp[0][2].vars[4]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[3] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[0][2].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
     ProgramCall @[4] {
      name="ProgramCall_GenDatainputdata_ohnepochsperenv";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="GenData(input_data, n_seqs_per_epcoh, n_epochs_per_env)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_seq";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="n_seqs_per_epcoh";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="n_epochs_per_env";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="n_epochs_per_env";
	};
       };
      };
      target=.programs.gp[2][0]$$;
      targ_ld_init="*GenData*";
     };
     NetDataLoop @[5] {
      name="NetDataLoop_NetDataLoopgrpPE_ardatalooporder";
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Data Loop (grp-PERMUTED itm-SEQUENTIAL):  table=input_data  group_index=group_index  index=data_loop_index  group_order_var=group_order  order_var=data_loop_order ";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraTrialnetworkinputdata";
	desc="run the trial program, passing network and input_data";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraTrial(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.programs.gp[0][3]$;
	targ_ld_init="*LeabraTrial*";
       };
       If @[1] {
	name="If_ifsteponerrnetworksse00";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (step_on_err && network.sse > 0.0)";
	cond {
	 expr="step_on_err && network.sse > 0.0";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 StopStepPoint @[0] {
	  name="StopStepPoint_StopStepPoint";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="Stop_Step Point";
	  cond {
	   expr=;
	  };
	 };
	};
       };
      };
      data_var=.programs.gp[0][2].args[1]$$;
      index_var=.programs.gp[0][2].vars[5]$$;
      order_var=.programs.gp[0][2].vars[0]$$;
      order=SEQUENTIAL;
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=1;
      group_col 9 0="Group";
      group_index_var=.programs.gp[0][2].vars[9]$$;
      group_order_var=.programs.gp[0][2].vars[8]$$;
      group_order=PERMUTED;
      group_idx_list{ 167;78;58;68;73;0;176;44;19;116;39;121;84;129;159;49;150;99;29;140;24;135;104;5;11;      };
     };
     If @[6] {
      name="If_ifnetworkwtupdateNetworkBATCH";
      desc="if full batch mode, update only at end of epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.wt_update == Network::BATCH)";
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="final update of weights based on accumulated changes";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[7] {
      name="MethodCall_networkComputeEpochStats";
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=$.programs.gp[0][2].args[0]$;
      method=Network::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more";
     };
     MethodCall @[8] {
      name="MethodCall_epochtimerEndTimer";
      desc="done with the computation in the epoch -- record time it took";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[0][2].vars[4]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[9] {
      name="ProgramCall_LeabraEpochMonitornetwork";
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraEpochMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[0][8]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
    };
    step_prog=.programs.gp[0][5]$$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][3].doc$$: };
    };
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/output event or external information, over a single alpha frequency cycle (100 msec / 10 Hz) -- iterates over gamma-frequency (25 msec / 40 Hz) quarter-trials";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars1vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="qtr";
	var_type=T_Int;
	int_val=0;
	completion_type=;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     If @[1] {
      name="If_ifnetworkCompute_stnetworktrial1";
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.Compute_Weights_Test(network.trial+1))";
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="update weights -- do this at start instead of end, so that dwt is valid";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=.programs.gp[0][3].args[0]$$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[2] {
      name="MethodCall_networkTrialInit";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init()";
      result_var=NULL;
      obj=$.programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init()";
      meth_desc=" initialize at start of trial (init specs, Decay state)";
     };
     Comment @[3] {
      name="Comment_notecanapplyinpu_Quarterasneeded";
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     MethodCall @[4] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[0][3].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[5] {
      name="ProgramCall_ApplyInputsnetworkinputdata";
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.programs.gp[0][6]$$;
      targ_ld_init="*ApplyInputs*";
     };
     ForLoop @[6] {
      name="ForLoop_forqtr0qtr4qtr";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (qtr = 0; qtr < 4; qtr++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraQuarternetworkinputdata";
	desc="run the quarter program (which iterates over cyles of network activation updating) for each quarter";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraQuarter(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.programs.gp[0][4]$$;
	targ_ld_init="*LeabraQuarter*";
       };
      };
      init {
       expr="qtr = 0";
      };
      test {
       expr="qtr < 4";
      };
      iter {
       expr="qtr++";
      };
     };
     MethodCall @[7] {
      name="MethodCall_networkTrialFinal";
      desc="after the trial is over, do final computations";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Final()";
      result_var=NULL;
      obj=$.programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Final()";
      meth_desc=" do final processing after trial: Compute_AbsRelNetin";
     };
     ProgramCall @[8] {
      name="ProgramCall_LeabraTrialMonitornetwork";
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraTrialMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[0][7]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[9] {
      name="NetUpdateView_NetUpdateView";
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[0][3].args[0]$;
      update_var=.programs.gp[0][3].vars[0]$$;
     };
    };
    step_prog=$.programs.gp[0][5]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][4].doc$$: };
    };
    name="LeabraQuarter";
    short_nm="Quarter";
    tags="Leabra, Std";
    desc="iterates over cycles of activation updating for a gamma-frequency (25 msec / 40 Hz) quarter of an alpha frequency (100 msec / 10 Hz) trial";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitcycle";
      desc="initialize local cycle counter and corresponding counter on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: cycle";
      network_var=.programs.gp[0][4].args[0]$$;
      local_ctr_var=.programs.gp[0][4].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars2vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (2 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="cycle_max";
	var_type=T_Int;
	int_val=0;
	completion_type=;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="cyc";
	var_type=T_Int;
	int_val=0;
	completion_type=;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     NetCounterInit @[1] {
      name="NetCounterInit_NetCounterInitcycle";
      desc="initialize local cycle counter and corresponding counter on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: cycle";
      network_var=$.programs.gp[0][4].args[0]$;
      local_ctr_var=$.programs.gp[0][4].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     Comment @[2] {
      name="Comment_notecanapplyinpu_Quarterasneeded";
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     MethodCall @[3] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[0][4].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[4] {
      name="ProgramCall_ApplyInputsnetworkinputdata";
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=$.programs.gp[0][6]$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[5] {
      name="MethodCall_networkQuarterInit";
      desc="initializes various counters at start of settling";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Init()";
      result_var=NULL;
      obj=$.programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Quarter_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Init()";
      meth_desc=" initialize network for quarter-level processing (hard clamp, netscale)";
     };
     MethodCall @[6] {
      name="MethodCall_cyclemaxnetworkCycleRunMax";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="cycle_max = network->CycleRunMax()";
      result_var=.programs.gp[0][4].prog_code[0].local_vars[0]$$;
      obj=$.programs.gp[0][4].args[0]$;
      method=LeabraNetwork::CycleRunMax;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int CycleRunMax()";
      meth_desc=" max loop counter for running cycles in a gamma quarter of processing, taking into account the fact that threading can run multiple cycles per Cycle_Run call if quarter flag is set";
     };
     ForLoop @[7] {
      name="ForLoop_forcyc0cyccyclemaxcyc";
      desc="// the main loop over cycles of updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="for (cyc=0; cyc<cycle_max; cyc++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraCyclenetwork";
	desc="run the cycle program -- can run multiple cycles at a time due to threading";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraCycle(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[0][5]$;
	targ_ld_init="*LeabraCycle*";
       };
       AssignExpr @[1] {
	name="AssignExpr_cyclenetworkcycle";
	desc="grab the updated cycle count";
	flags=CAN_REVERT_TO_CODE;
	code_string="cycle = network.cycle";
	result_var=$.programs.gp[0][4].vars[0]$;
	expr {
	 expr="network.cycle";
	};
       };
      };
      init {
       expr="cyc=0";
      };
      test {
       expr="cyc<cycle_max";
      };
      iter {
       expr="cyc++";
      };
     };
     MethodCall @[8] {
      name="MethodCall_networkQuarterFinal";
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Final()";
      result_var=NULL;
      obj=$.programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Quarter_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Final()";
      meth_desc=" do final processing after each quarter: ";
     };
     MethodCall @[9] {
      name="MethodCall_networkComputePhaseStats";
      desc="compute appropriate stats for each phase (MinusStats, PlusStats)";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=$.programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[10] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[0][4].args[0]$;
      update_var=.programs.gp[0][4].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[5] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][5].doc$$: };
    };
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkCycleRun";
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Cycle_Run()";
      result_var=NULL;
      obj=.programs.gp[0][5].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Cycle_Run()";
      meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
     };
     NetUpdateView @[1] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[0][5].args[0]$;
      update_var=$.programs.gp[0][5].vars[0]$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[6] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][6].doc$$: };
    };
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][0]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	off=0;
	col_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	off=0;
	col_name="Targets";
	net_target=LAYER;
	layer_name="Targets";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	off=0;
	col_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	off=0;
	col_name="Group";
	net_target=GROUP_NAME;
	layer_name="Group";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      completion_type=;
      object_val=.programs.gp[0][6].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[0][6].objs_vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[0][6].objs_vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=$.programs.gp[0][6].objs_vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[0][6].objs_vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[7] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][7].doc$$: };
    };
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       ignore_sig=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="group";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="group";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="quarter";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="quarter";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="rt_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="rt_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="fsa_err";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=$.data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      completion_type=;
      object_val=.programs.gp[0][7].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="fsa_err";
      var_type=T_Real;
      real_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="i";
      var_type=T_Int;
      int_val=15;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="Var_4";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialnetmonSetDa_lmondatanetwork";
      desc="set the network and datatable for the NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[0][7].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonCheckConfigfalse";
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[0][7].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[2] {
      name="MethodCall_trialnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[0][7].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[0][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonGetMonVals";
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[0][7].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     AssignExpr @[2] {
      name="AssignExpr_fsaerr00";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="fsa_err = 0.0";
      result_var=.programs.gp[0][7].vars[1]$$;
      expr {
       expr="0.0";
      };
     };
     If @[3] {
      name="If_ifnetworklayersInputactsmmax05";
      desc="nobody active above threshold";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.layers.Input.acts_m.max < 0.5)";
      cond {
       expr="network.layers.Input.acts_m.max < 0.5";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_fsaerr10";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="fsa_err = 1.0";
	result_var=$.programs.gp[0][7].vars[1]$;
	expr {
	 expr="1.0";
	};
       };
      };
     };
     Else @[4] {
      name="Else_If_ifnetworklayersInputactsmmax05";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="else";
      cond {
       expr=;
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ForLoop @[0] {
	name="ForLoop_fori0inetworklayersInputPnunitsi";
	desc="loop over output units to see which unit is active and whether it's not a target";
	flags=NON_STD|CAN_REVERT_TO_CODE;
	code_string="for (i = 0; i < network.layers.InputP.n_units; i++)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 If @[0] {
	  name="If_ifnetworklayersI_tUnitIdxiactm05";
	  desc="if unit is active";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (network.layers.InputP.GetUnitIdx(i).act_m >=0.5)";
	  cond {
	   expr="network.layers.InputP.GetUnitIdx(i).act_m >=0.5";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   If @[0] {
	    name="If_ifnetworklayersT_etUnitIdxiact05";
	    desc="if target is not";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="if (network.layers.Targets.GetUnitIdx(i).act <0.5)";
	    cond {
	     expr="network.layers.Targets.GetUnitIdx(i).act <0.5";
	    };
	    true_code {
	     name="true_code";
	     el_typ=ProgCode;
	     el_def=0;
	     AssignExpr @[0] {
	      name="AssignExpr_fsaerr10";
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="fsa_err = 1.0";
	      result_var=$.programs.gp[0][7].vars[1]$;
	      expr {
	       expr="1.0";
	      };
	     };
	     UserScript @[1] {
	      name="UserScript_break";
	      desc="just break -- i think this is the only way to do it...";
	      flags=CAN_REVERT_TO_CODE;
	      code_string="break;";
	      script {
	       expr="break;";
	      };
	     };
	    };
	   };
	  };
	 };
	};
	init {
	 expr="i = 0";
	};
	test {
	 expr="i < network.layers.InputP.n_units";
	};
	iter {
	 expr="i++";
	};
       };
      };
     };
     DataVarProg @[5] {
      name="DataVarProg_DataTotabletrial_errvar2var3var4";
      desc="assign the fsa_err stat";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="Data To:  table=trial_mon_data  row_spec=cur_row  set=to  all_matches=false  var_1=fsa_err  var_2=?  var_3=?  var_4=? ";
      data_var=$.programs.gp[0][7].vars[0]$;
      row_spec=CUR_ROW;
      row_var=NULL;
      set_data=1;
      all_matches=0;
      quiet=0;
      var_1=$.programs.gp[0][7].vars[1]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     MethodCall @[6] {
      name="MethodCall_trialmondataWriteClose";
      desc="update views and other things after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[0][7].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
     MethodCall @[7] {
      name="MethodCall_networkDMemShare_tatrialmondata1";
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
      result_var=NULL;
      obj=.programs.gp[0][7].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	prev_expr=;
	expr {
	 expr="1";
	};
       };
      };
      meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
      meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[8] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][8].doc$$: };
    };
    name="LeabraEpochMonitor";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       ignore_sig=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="fsa_err_sum";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=$.data.gp[1][2]$;
      rmv_orphan_cols=1;
     };
     DataTable @[1] {
      name="aggregated_fsa_err";
      desc=;
      data {
       name="data";
       el_typ=float_Data;
       el_def=0;
       float_Data @[0] {
	name="fsa_err_sum";
	col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[1] 0;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [1] 0;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      completion_type=;
      object_val=.programs.gp[0][8].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="aggregated_fsa_err";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[0][8].objs[1]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][2]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      completion_type=;
      object_val=$.networks[0].epoch_time$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="fsa_err_sum";
      var_type=T_Real;
      real_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[0][8].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonSetDa_hmondatanetwork";
      desc="set data and network on NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[0][8].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[2] {
      name="MethodCall_epochnetmonCheckConfigfalse";
      desc="check configuration and emit errors/warnings for problems";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[0][8].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[3] {
      name="MethodCall_epochnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[0][8].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_epochmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[0][8].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonGetMonVals";
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[0][8].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     AssignExpr @[2] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[0][8].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      name="MethodCall_epochmondataSetV_csepochtimetot1";
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     MethodCall @[4] {
      name="MethodCall_epochmondataSetV_csepochtimeusr1";
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     DataGroupProg @[5] {
      name="DataGroupProg_Groupfromsrctabl_ggregatedfsaerr";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="Group from:  src table = trial_mon_data dest table = aggregated_fsa_err";
      src_table=;
      dest_table=;
      src_data_var=.programs.gp[0][8].vars[1]$$;
      dest_data_var=.programs.gp[0][8].objs_vars[1]$$;
      group_spec {
       name="group_spec";
       ops {
	name="ops";
	el_typ=DataGroupEl;
	el_def=0;
	DataGroupEl @[0] {
	 col_name="fsa_err";
	 name="fsa_err_SUM_0";
	 agg {name="Aggregate": op=SUM: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	};
       };
       append_agg_name=1;
      };
     };
     MethodCall @[6] {
      name="MethodCall_fsaerrsumaggrega_dfsaerrGetVal00";
      desc="gets the aggregate stat";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="fsa_err_sum = aggregated_fsa_err->GetVal(0, 0)";
      result_var=.programs.gp[0][8].vars[3]$$;
      obj=$.programs.gp[0][8].objs_vars[1]$;
      method=DataTable::GetVal;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="col";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="0";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="0";
	};
       };
      };
      meth_sig="const_Variant GetVal(Variant& col, int row)";
      meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
     };
     DataVarProg @[7] {
      name="DataVarProg_DataTotableepoch_sumvar2var3var4";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="Data To:  table=epoch_mon_data  row_spec=cur_row  set=to  all_matches=false  var_1=fsa_err_sum  var_2=?  var_3=?  var_4=? ";
      data_var=$.programs.gp[0][8].vars[0]$;
      row_spec=CUR_ROW;
      row_var=NULL;
      set_data=1;
      all_matches=0;
      quiet=0;
      var_1=$.programs.gp[0][8].vars[3]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     MemberAssign @[8] {
      name="MemberAssign_networkcnterrfsaerrsum";
      desc="sets cnt_err to the more relevant statistic (for stopping purposes)";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="network.cnt_err = fsa_err_sum";
      obj=.programs.gp[0][8].args[0]$$;
      path="cnt_err";
      expr {
       expr="fsa_err_sum";
      };
      update_after=0;
     };
     MethodCall @[9] {
      name="MethodCall_epochmondataWriteClose";
      desc="update after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[0][8].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[9] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][9].doc$$: };
    };
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val="_gui";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val="/Users/oreilly/svn_sims/leabra/ti/fsa_deep.02_0050.wts.gz";
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0050";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="02";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".02_0050";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_iftaMiscdmemproc0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_proc > 0)";
      cond {
       expr="taMisc::dmem_proc > 0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ReturnExpr @[0] {
	name="ReturnExpr_return";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="return ";
	expr {
	 expr=;
	};
       };
      };
     };
     MiscCall @[1] {
      name="MiscCall_batchstrtaMiscLe_osnetworkbatch2";
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=CAN_REVERT_TO_CODE;
      code_string="batch_str = taMisc::LeadingZeros(network.batch, 2)";
      result_var=.programs.gp[0][9].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      name="MiscCall_epochstrtaMiscLe_osnetworkepoch4";
      desc="get current epoch counter with leading zeros to length 4";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_str = taMisc::LeadingZeros(network.epoch, 4)";
      result_var=.programs.gp[0][9].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      name="AssignExpr_finaltagtagbatchstrepochstr";
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=CAN_REVERT_TO_CODE;
      code_string="final_tag = tag + \".\" + batch_str + \"_\" + epoch_str";
      result_var=.programs.gp[0][9].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      name="MethodCall_fnamenetworkGetF_gwtssubdirfalse";
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=CAN_REVERT_TO_CODE;
      code_string="fname = network->GetFileNameFmProject(\".wts.gz\", final_tag, wts_subdir, false)";
      result_var=.programs.gp[0][9].vars[2]$$;
      obj=.programs.gp[0][9].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="ext";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
      meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
     };
     MethodCall @[5] {
      name="MethodCall_networkSaveWeigh_meNetworkNETFMT";
      desc="save the weights to that file name";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->SaveWeights(fname, Network::NET_FMT)";
      result_var=NULL;
      obj=$.programs.gp[0][9].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	prev_expr=;
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
      meth_sig="void SaveWeights(taString& fname, Network::WtSaveFormat fmt = NET_FMT)";
      meth_desc=" write weight values out in a simple ordered list of weights (optionally in binary fmt) (leave fname empty to pull up file chooser)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[1] {
   name="LeabraAll_Test";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All, Test";
   desc="The full set of programs for testing a standard Leabra network (starting with Epoch)";
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][0].doc$$: };
    };
    name="LeabraEpochGpDataTest";
    short_nm="EpcTst";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="group_order";
      var_type=T_HardEnum;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      hard_enum_type=NetGroupedDataLoop::Order;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="item_order";
      var_type=T_HardEnum;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      hard_enum_type=NetGroupedDataLoop::Order;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial";
      var_type=T_Int;
      int_val=4;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.data.gp[1][1]$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- if we want to reset it every epoch";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      completion_type=;
      object_val=$.networks[0].epoch_time$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="group_index";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[6] {
      name="item_index";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[7] {
      name="n_test_inputs";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter: note also needs to do this in regular running program";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=.programs.gp[1][0].args[0]$$;
      local_ctr_var=.programs.gp[1][0].vars[2]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[1][0].vars[4]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=$.programs.gp[1][0].args[0]$;
      local_ctr_var=$.programs.gp[1][0].vars[2]$;
      counter=Network::trial;
      update_after=0;
     };
     MemberAssign @[1] {
      name="MemberAssign_networktrainmodeNetworkTEST";
      desc="set to testing mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TEST";
      obj=$.programs.gp[1][0].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TEST";
      };
      update_after=0;
     };
     ProgramCall @[2] {
      name="ProgramCall_GenDatainputdatantestinputs1";
      desc="generates data -- called here so you can step through a sequence";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="GenData(input_data, n_test_inputs, 1)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_seq";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="n_test_inputs";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="n_epochs_per_env";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="1";
	};
       };
      };
      target=$.programs.gp[2][0]$;
      targ_ld_init="*GenData*";
     };
     AssignExpr @[3] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[1][0].vars[4]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[4] {
      name="MethodCall_epochtimerStartTimertrue";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->StartTimer(true)";
      result_var=NULL;
      obj=$.programs.gp[1][0].vars[4]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[5] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn OFF if not wanted)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[1][0].vars[3]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
     NetGroupedDataLoop @[6] {
      name="NetGroupedDataLoop_NetGroupedDataLo_mindexitemindex";
      desc="iterates over groups and items within groups";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Grouped Data Loop (gp: PERMUTED
 itm: SEQUENTIAL over: input_data group index: group_index item index: item_index)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraTrialTestnetworkinputdata";
	desc="call the trial process";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraTrialTest(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.programs.gp[1][2]$$;
	targ_ld_init="*LeabraTrial*";
       };
       If @[1] {
	name="If_ifnetworkCompute_ightsTesttrial1";
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=CAN_REVERT_TO_CODE;
	code_string="if (network.Compute_Weights_Test(trial+1))";
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_networkComputeWeights";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="network->Compute_Weights()";
	  result_var=NULL;
	  obj=$.programs.gp[1][0].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void Compute_Weights()";
	  meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
	 };
	};
       };
      };
      data_var=.programs.gp[1][0].args[1]$$;
      group_index_var=.programs.gp[1][0].vars[5]$$;
      item_index_var=.programs.gp[1][0].vars[6]$$;
      group_order_var=.programs.gp[1][0].vars[0]$$;
      item_order_var=.programs.gp[1][0].vars[1]$$;
      group_order=PERMUTED;
      item_order=SEQUENTIAL;
      group_col=0;
      update_after=0;
      group_idx_list{ 28;23;5;10;0;      };
      item_idx_list{ 0;1;2;3;4;      };
     };
     If @[7] {
      name="If_ifnetworkwtupdateNetworkBATCH";
      desc="if full batch mode, update only at end of epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.wt_update == Network::BATCH)";
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.programs.gp[1][0].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[8] {
      name="MethodCall_networkComputeEpochStats";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=$.programs.gp[1][0].args[0]$;
      method=Network::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more";
     };
     MethodCall @[9] {
      name="MethodCall_epochtimerEndTimer";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[1][0].vars[4]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[10] {
      name="ProgramCall_LeabraEpochMonitorTestnetwork";
      desc="call the epoch monitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraEpochMonitorTest(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[1][7]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     MemberAssign @[11] {
      name="MemberAssign_networktrainmodeNetworkTRAIN";
      desc="set back to training mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TRAIN";
      obj=$.programs.gp[1][0].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TRAIN";
      };
      update_after=0;
     };
    };
    step_prog=.programs.gp[1][3]$$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][1].doc$$: };
    };
    name="LeabraEpochTest";
    short_nm="EpchTst";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=2;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      hard_enum_type=DataLoop::Order;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="step_on_err";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="when you step at the Epoch level, this will automatically step through to the next point at which an error was made -- you can use the netview history to replay what happend";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      completion_type=;
      object_val=$.networks[0].epoch_time$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=7;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="n_epochs_per_env";
      var_type=T_Int;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[7] {
      name="n_seqs_per_epcoh";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[8] {
      name="group_order";
      var_type=T_HardEnum;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      hard_enum_type=DataLoop::Order;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[9] {
      name="group_index";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=.programs.gp[1][1].args[0]$$;
      local_ctr_var=.programs.gp[1][1].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[1][1].vars[4]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MemberAssign @[0] {
      name="MemberAssign_networktrainmodeNetworkTEST";
      desc="set to testing mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TEST";
      obj=$.programs.gp[1][1].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TEST";
      };
      update_after=0;
     };
     NetCounterInit @[1] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=$.programs.gp[1][1].args[0]$;
      local_ctr_var=$.programs.gp[1][1].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[2] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get pointer to epoch timer object on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[1][1].vars[4]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      name="MethodCall_epochtimerStartTimertrue";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->StartTimer(true)";
      result_var=NULL;
      obj=$.programs.gp[1][1].vars[4]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[4] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[1][1].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
     ProgramCall @[5] {
      name="ProgramCall_GenDatainputdata_ohnepochsperenv";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="GenData(input_data, n_seqs_per_epcoh, n_epochs_per_env)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_seq";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="n_seqs_per_epcoh";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="n_epochs_per_env";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="n_epochs_per_env";
	};
       };
      };
      target=$.programs.gp[2][0]$;
      targ_ld_init="*GenData*";
     };
     NetDataLoop @[6] {
      name="NetDataLoop_NetDataLoopgrpSE_ardatalooporder";
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Data Loop (grp-SEQUENTIAL itm-SEQUENTIAL):  table=input_data  group_index=group_index  index=data_loop_index  group_order_var=group_order  order_var=data_loop_order ";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraTrialTestnetworkinputdata";
	desc="run the trial program, passing network and input_data";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraTrialTest(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.programs.gp[1][2]$;
	targ_ld_init="*LeabraTrial*";
       };
       If @[1] {
	name="If_ifsteponerrnetworksse00";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (step_on_err && network.sse > 0.0)";
	cond {
	 expr="step_on_err && network.sse > 0.0";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 StopStepPoint @[0] {
	  name="StopStepPoint_StopStepPoint";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="Stop_Step Point";
	  cond {
	   expr=;
	  };
	 };
	};
       };
      };
      data_var=.programs.gp[1][1].args[1]$$;
      index_var=.programs.gp[1][1].vars[5]$$;
      order_var=.programs.gp[1][1].vars[0]$$;
      order=SEQUENTIAL;
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=1;
      group_col 9 0="Group";
      group_index_var=.programs.gp[1][1].vars[9]$$;
      group_order_var=.programs.gp[1][1].vars[8]$$;
      group_order=SEQUENTIAL;
      group_idx_list{ 99;6;137;85;157;62;144;32;162;94;123;45;105;37;12;57;27;0;177;74;79;110;118;169;52;      };
     };
     If @[7] {
      name="If_ifnetworkwtupdateNetworkBATCH";
      desc="if full batch mode, update only at end of epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.wt_update == Network::BATCH)";
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="final update of weights based on accumulated changes";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.programs.gp[1][1].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[8] {
      name="MethodCall_networkComputeEpochStats";
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=$.programs.gp[1][1].args[0]$;
      method=Network::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more";
     };
     MethodCall @[9] {
      name="MethodCall_epochtimerEndTimer";
      desc="done with the computation in the epoch -- record time it took";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[1][1].vars[4]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[10] {
      name="ProgramCall_LeabraEpochMonitorTestnetwork";
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraEpochMonitorTest(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[1][7]$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     MemberAssign @[11] {
      name="MemberAssign_networktrainmodeNetworkTRAIN";
      desc="set to testing mode";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network.train_mode = Network::TRAIN";
      obj=$.programs.gp[1][1].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TRAIN";
      };
      update_after=0;
     };
    };
    step_prog=$.programs.gp[0][5]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][2].doc$$: };
    };
    name="LeabraTrialTest";
    short_nm="TrlTst";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/output event or external information, over a single alpha frequency cycle (100 msec / 10 Hz) -- iterates over gamma-frequency (25 msec / 40 Hz) quarter-trials";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars1vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="qtr";
	var_type=T_Int;
	int_val=0;
	completion_type=;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     If @[1] {
      name="If_ifnetworkCompute_stnetworktrial1";
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.Compute_Weights_Test(network.trial+1))";
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="update weights -- do this at start instead of end, so that dwt is valid";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=.programs.gp[1][2].args[0]$$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[2] {
      name="MethodCall_networkTrialInit";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init()";
      result_var=NULL;
      obj=$.programs.gp[1][2].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init()";
      meth_desc=" initialize at start of trial (init specs, Decay state)";
     };
     Comment @[3] {
      name="Comment_notecanapplyinpu_Quarterasneeded";
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     MethodCall @[4] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[1][2].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[5] {
      name="ProgramCall_ApplyInputsTestnetworkinputdata";
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=CAN_REVERT_TO_CODE;
      code_string="ApplyInputsTest(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.programs.gp[1][5]$$;
      targ_ld_init="*ApplyInputs*";
     };
     ForLoop @[6] {
      name="ForLoop_forqtr0qtr4qtr";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (qtr = 0; qtr < 4; qtr++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraQuarterTes_etworkinputdata";
	desc="run the quarter program (which iterates over cyles of network activation updating) for each quarter";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraQuarterTest(network, input_data)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.programs.gp[1][3]$;
	targ_ld_init="*LeabraQuarter*";
       };
      };
      init {
       expr="qtr = 0";
      };
      test {
       expr="qtr < 4";
      };
      iter {
       expr="qtr++";
      };
     };
     MethodCall @[7] {
      name="MethodCall_networkTrialFinal";
      desc="after the trial is over, do final computations";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Final()";
      result_var=NULL;
      obj=$.programs.gp[1][2].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Final()";
      meth_desc=" do final processing after trial: Compute_AbsRelNetin";
     };
     ProgramCall @[8] {
      name="ProgramCall_LeabraTrialMonitorTestnetwork";
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraTrialMonitorTest(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[1][6]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[9] {
      name="NetUpdateView_NetUpdateView";
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[1][2].args[0]$;
      update_var=.programs.gp[1][2].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][3].doc$$: };
    };
    name="LeabraQuarterTest";
    short_nm="QrtTst";
    tags="Leabra, Std";
    desc="iterates over cycles of activation updating for a gamma-frequency (25 msec / 40 Hz) quarter of an alpha frequency (100 msec / 10 Hz) trial";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=100;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitcycle";
      desc="initialize local cycle counter and corresponding counter on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: cycle";
      network_var=.programs.gp[1][3].args[0]$$;
      local_ctr_var=.programs.gp[1][3].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars2vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (2 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="cycle_max";
	var_type=T_Int;
	int_val=0;
	completion_type=;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="cyc";
	var_type=T_Int;
	int_val=0;
	completion_type=;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     NetCounterInit @[1] {
      name="NetCounterInit_NetCounterInitcycle";
      desc="initialize local cycle counter and corresponding counter on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: cycle";
      network_var=$.programs.gp[1][3].args[0]$;
      local_ctr_var=$.programs.gp[1][3].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     Comment @[2] {
      name="Comment_notecanapplyinpu_Quarterasneeded";
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     MethodCall @[3] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[1][3].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[4] {
      name="ProgramCall_programname";
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="program_name()";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=NULL;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[5] {
      name="MethodCall_networkQuarterInit";
      desc="initializes various counters at start of settling";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Init()";
      result_var=NULL;
      obj=$.programs.gp[1][3].args[0]$;
      method=LeabraNetwork::Quarter_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Init()";
      meth_desc=" initialize network for quarter-level processing (hard clamp, netscale)";
     };
     MethodCall @[6] {
      name="MethodCall_cyclemaxnetworkCycleRunMax";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="cycle_max = network->CycleRunMax()";
      result_var=.programs.gp[1][3].prog_code[0].local_vars[0]$$;
      obj=$.programs.gp[1][3].args[0]$;
      method=LeabraNetwork::CycleRunMax;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int CycleRunMax()";
      meth_desc=" max loop counter for running cycles in a gamma quarter of processing, taking into account the fact that threading can run multiple cycles per Cycle_Run call if quarter flag is set";
     };
     ForLoop @[7] {
      name="ForLoop_forcyc0cyccyclemaxcyc";
      desc="// the main loop over cycles of updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="for (cyc=0; cyc<cycle_max; cyc++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_LeabraCycleTestnetwork";
	desc="run the cycle program -- can run multiple cycles at a time due to threading";
	flags=CAN_REVERT_TO_CODE;
	code_string="LeabraCycleTest(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.programs.gp[1][4]$$;
	targ_ld_init="*LeabraCycle*";
       };
       AssignExpr @[1] {
	name="AssignExpr_cyclenetworkcycle";
	desc="grab the updated cycle count";
	flags=CAN_REVERT_TO_CODE;
	code_string="cycle = network.cycle";
	result_var=$.programs.gp[1][3].vars[0]$;
	expr {
	 expr="network.cycle";
	};
       };
      };
      init {
       expr="cyc=0";
      };
      test {
       expr="cyc<cycle_max";
      };
      iter {
       expr="cyc++";
      };
     };
     MethodCall @[8] {
      name="MethodCall_networkQuarterFinal";
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Final()";
      result_var=NULL;
      obj=$.programs.gp[1][3].args[0]$;
      method=LeabraNetwork::Quarter_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Final()";
      meth_desc=" do final processing after each quarter: ";
     };
     MethodCall @[9] {
      name="MethodCall_networkComputePhaseStats";
      desc="compute appropriate stats for each phase (MinusStats, PlusStats)";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=$.programs.gp[1][3].args[0]$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[10] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[1][3].args[0]$;
      update_var=.programs.gp[1][3].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][4].doc$$: };
    };
    name="LeabraCycleTest";
    short_nm="CycTst";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkCycleRun";
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Cycle_Run()";
      result_var=NULL;
      obj=.programs.gp[1][4].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Cycle_Run()";
      meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
     };
     NetUpdateView @[1] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[1][4].args[0]$;
      update_var=.programs.gp[1][4].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[5] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][5].doc$$: };
    };
    name="ApplyInputsTest";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][0]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	off=0;
	col_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	off=0;
	col_name="Targets";
	net_target=LAYER;
	layer_name="Targets";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	off=0;
	col_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	off=0;
	col_name="Group";
	net_target=GROUP_NAME;
	layer_name="Group";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="noise": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      completion_type=;
      object_val=.programs.gp[1][5].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[1][5].objs_vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[1][5].objs_vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=$.programs.gp[1][5].objs_vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[1][5].objs_vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[6] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][6].doc$$: };
    };
    name="LeabraTrialMonitorTest";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="John Rohrlich";
    email="john.rohrlich@colorado.edu";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       ignore_sig=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="rt_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="rt_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="fsa_err";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="Hidden_act";
	computed=0;
	object_type=LeabraLayer;
	object=.networks[0].layers[3]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="Input_act";
	computed=0;
	object_type=LeabraLayer;
	object=.networks[0].layers[0]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="Target_act";
	computed=0;
	object_type=LeabraLayer;
	object=.networks[0].layers[2]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=$.data.gp[1][1]$;
      rmv_orphan_cols=1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      completion_type=;
      object_val=.programs.gp[1][6].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="i";
      var_type=T_Int;
      int_val=15;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fsa_err";
      var_type=T_Real;
      real_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialnetmonSetDa_lmondatanetwork";
      desc="set the network and datatable for the NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[1][6].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonCheckConfigfalse";
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[1][6].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[2] {
      name="MethodCall_trialnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[1][6].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_trialmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[1][6].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_trialnetmonGetMonVals";
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[1][6].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     AssignExpr @[2] {
      name="AssignExpr_fsaerr00";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="fsa_err = 0.0";
      result_var=.programs.gp[1][6].vars[2]$$;
      expr {
       expr="0.0";
      };
     };
     ForLoop @[3] {
      name="ForLoop_fori0inetworklayersInputnunitsi";
      desc="loop over output units to see which unit is active and whether it's not a target";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < network.layers.Input.n_units; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       If @[0] {
	name="If_ifnetworklayersI_etUnitIdxiact05";
	desc="if the current unit is active";
	flags=CAN_REVERT_TO_CODE;
	code_string="if (network.layers.Input.GetUnitIdx(i).act >=0.5)";
	cond {
	 expr="network.layers.Input.GetUnitIdx(i).act >=0.5";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 If @[0] {
	  name="If_ifnetworklayersT_etUnitIdxiact05";
	  desc="it it's not a target, then assign err= 1";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (network.layers.Targets.GetUnitIdx(i).act<0.5)";
	  cond {
	   expr="network.layers.Targets.GetUnitIdx(i).act<0.5";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   AssignExpr @[0] {
	    name="AssignExpr_fsaerr10";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="fsa_err = 1.0";
	    result_var=$.programs.gp[1][6].vars[2]$;
	    expr {
	     expr="1.0";
	    };
	   };
	   UserScript @[1] {
	    name="UserScript_break";
	    desc="break after it sees an error";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="break;";
	    script {
	     expr="break;";
	    };
	   };
	  };
	 };
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < network.layers.Input.n_units";
      };
      iter {
       expr="i++";
      };
     };
     DataVarProg @[4] {
      name="DataVarProg_DataTotabletrial_errvar2var3var4";
      desc="assign the fsa_err stat";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="Data To:  table=trial_mon_data  row_spec=cur_row  set=to  all_matches=false  var_1=fsa_err  var_2=?  var_3=?  var_4=? ";
      data_var=$.programs.gp[1][6].vars[0]$;
      row_spec=CUR_ROW;
      row_var=NULL;
      set_data=1;
      all_matches=0;
      quiet=1;
      var_1=$.programs.gp[1][6].vars[2]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     MethodCall @[5] {
      name="MethodCall_trialmondataWriteClose";
      desc="update views and other things after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[1][6].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
     MethodCall @[6] {
      name="MethodCall_networkDMemShare_tatrialmondata1";
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
      result_var=NULL;
      obj=.programs.gp[1][6].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	prev_expr=;
	expr {
	 expr="1";
	};
       };
      };
      meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
      meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[7] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][7].doc$$: };
    };
    name="LeabraEpochMonitorTest";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name="items";
       el_typ=NetMonItem;
       el_def=0;
       ignore_sig=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="fsa_err_sum";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 name="_EQUAL_";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.networks[0]$;
      data=.data.gp[1][3]$$;
      rmv_orphan_cols=1;
     };
     DataTable @[1] {
      name="aggregated_fsa_err";
      desc=;
      data {
       name="data";
       el_typ=float_Data;
       el_def=0;
       float_Data @[0] {
	name="fsa_err_sum";
	col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[1] 0;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [1] 0;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      completion_type=;
      object_val=.programs.gp[1][7].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="aggregated_fsa_err";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[1][7].objs[1]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][3]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_mon_data_test";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      completion_type=;
      object_val=$.networks[0].epoch_time$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="fsa_err_sum";
      var_type=T_Real;
      real_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=.programs.gp[1][7].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonSetDa_hmondatanetwork";
      desc="set data and network on NetMonitor object";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
      result_var=NULL;
      obj=.programs.gp[1][7].objs_vars[0]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
      meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
     };
     MethodCall @[2] {
      name="MethodCall_epochnetmonCheckConfigfalse";
      desc="check configuration and emit errors/warnings for problems";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[1][7].objs_vars[0]$;
      method=taBase::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
     MethodCall @[3] {
      name="MethodCall_epochnetmonUpdateMonitorstrue";
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->UpdateMonitors(true)";
      result_var=NULL;
      obj=$.programs.gp[1][7].objs_vars[0]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void UpdateMonitors(bool reset_first = false)";
      meth_desc=" old name for UpdateDataTable";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_epochmondataAddBlankRow";
      desc="add a new blank row to the data";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->AddBlankRow()";
      result_var=NULL;
      obj=.programs.gp[1][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int AddBlankRow()";
      meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
     };
     MethodCall @[1] {
      name="MethodCall_epochnetmonGetMonVals";
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_netmon->GetMonVals()";
      result_var=NULL;
      obj=$.programs.gp[1][7].objs_vars[0]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void GetMonVals()";
      meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
     };
     AssignExpr @[2] {
      name="AssignExpr_epochtimernetworkepochtime";
      desc="get the epoch timer from current network";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_timer = network.epoch_time";
      result_var=$.programs.gp[1][7].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      name="MethodCall_epochmondataSetV_csepochtimetot1";
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[1][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     MethodCall @[4] {
      name="MethodCall_epochmondataSetV_csepochtimeusr1";
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
      result_var=NULL;
      obj=$.programs.gp[1][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
      meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
     };
     DataGroupProg @[5] {
      name="DataGroupProg_Groupfromsrctabl_ggregatedfsaerr";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="Group from:  src table = trial_mon_data_test dest table = aggregated_fsa_err";
      src_table=;
      dest_table=;
      src_data_var=.programs.gp[1][7].vars[1]$$;
      dest_data_var=.programs.gp[1][7].objs_vars[1]$$;
      group_spec {
       name="group_spec";
       ops {
	name="ops";
	el_typ=DataGroupEl;
	el_def=0;
	DataGroupEl @[0] {
	 col_name="fsa_err";
	 name="fsa_err_SUM_0";
	 agg {name="Aggregate": op=SUM: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	};
       };
       append_agg_name=1;
      };
     };
     MethodCall @[6] {
      name="MethodCall_fsaerrsumaggrega_dfsaerrGetVal00";
      desc="gets the aggregate stat";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="fsa_err_sum = aggregated_fsa_err->GetVal(0, 0)";
      result_var=.programs.gp[1][7].vars[3]$$;
      obj=$.programs.gp[1][7].objs_vars[1]$;
      method=DataTable::GetVal;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="col";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="0";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="0";
	};
       };
      };
      meth_sig="const_Variant GetVal(Variant& col, int row)";
      meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
     };
     DataVarProg @[7] {
      name="DataVarProg_DataTotableepoch_sumvar2var3var4";
      desc=;
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="Data To:  table=epoch_mon_data  row_spec=cur_row  set=to  all_matches=false  var_1=fsa_err_sum  var_2=?  var_3=?  var_4=? ";
      data_var=$.programs.gp[1][7].vars[0]$;
      row_spec=CUR_ROW;
      row_var=NULL;
      set_data=1;
      all_matches=0;
      quiet=1;
      var_1=$.programs.gp[1][7].vars[3]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     MemberAssign @[8] {
      name="MemberAssign_networkcnterrfsaerrsum";
      desc="sets cnt_err to the more relevant statistic (for stopping purposes)";
      flags=NON_STD|CAN_REVERT_TO_CODE;
      code_string="network.cnt_err = fsa_err_sum";
      obj=.programs.gp[1][7].args[0]$$;
      path="cnt_err";
      expr {
       expr="fsa_err_sum";
      };
      update_after=0;
     };
     MethodCall @[9] {
      name="MethodCall_epochmondataWriteClose";
      desc="update after writing new data to monitor data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_mon_data->WriteClose()";
      result_var=NULL;
      obj=$.programs.gp[1][7].vars[0]$;
      method=DataTable::WriteClose;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void WriteClose()";
      meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[2] {
   name="InputGeneration";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2][0].doc$$: };
    };
    name="GenData";
    short_nm="GenDat";
    tags=;
    desc="generally generates teh data -- has an arg to determine what kind of data to generate";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="John Rohrlich";
    email="john.rohrlich@colorado.edu";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="InputType";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="TRAIN_ENV";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="RANDOM";
	value=1;
	desc=;
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="n_seq";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="number of sequences to generate";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="n_epochs_per_env";
      var_type=T_Int;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="i";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="avg_length";
      var_type=T_Real;
      real_val=7.24;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="input_type";
      var_type=T_DynEnum;
      completion_type=;
      object_scope=NULL;
      dyn_enum_val {
       user_data_=NULL;
       enum_type=.programs.gp[2][0].types[0]$$;
       value=0;
      };
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="fsa_ti";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_iffsatiepochnepochsperenv0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (fsa_ti.epoch % n_epochs_per_env != 0)";
      cond {
       expr="fsa_ti.epoch % n_epochs_per_env != 0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ReturnExpr @[0] {
	name="ReturnExpr_return";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="return ";
	expr {
	 expr=;
	};
       };
      };
     };
     ResetDataRows @[1] {
      name="ResetDataRows_ResetDataRowstableinputdata";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ResetDataRows:  table = input_data ";
      data_var=.programs.gp[2][0].args[0]$$;
     };
     ForLoop @[2] {
      name="ForLoop_fori0inseqi";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < n_seq; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       Switch @[0] {
	name="Switch_switchinputtype";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="switch(input_type)";
	switch_var=.programs.gp[2][0].vars[2]$$;
	cases {
	 name="cases";
	 el_typ=CaseBlock;
	 el_def=0;
	 CaseBlock @[0] {
	  name="CaseBlock_caseTRAINENV";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: TRAIN_ENV";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ProgramCall @[0] {
	    name="ProgramCall_ReberGenSequenceinputdatai";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="ReberGenSequence(input_data, i)";
	    prog_args {
	     name="prog_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DataTable;
	      type="DataTable*";
	      name="input_data";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="input_data";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=int;
	      type="int";
	      name="seq_no";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="i";
	      };
	     };
	    };
	    target=.programs.gp[2][1]$$;
	    targ_ld_init="*ReberGenSequence*";
	   };
	  };
	  case_val {
	   expr="TRAIN_ENV";
	  };
	  is_default=0;
	 };
	 CaseBlock @[1] {
	  name="CaseBlock_caseRANDOM";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: RANDOM";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ProgramCall @[0] {
	    name="ProgramCall_RandomGenSequenceinputdatai";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="RandomGenSequence(input_data, i)";
	    prog_args {
	     name="prog_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DataTable;
	      type="DataTable*";
	      name="input_data";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="input_data";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=int;
	      type="int";
	      name="seq_no";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="i";
	      };
	     };
	    };
	    target=.programs.gp[2][2]$$;
	    targ_ld_init="*RandomGenSequence*";
	   };
	  };
	  case_val {
	   expr="RANDOM";
	  };
	  is_default=0;
	 };
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < n_seq";
      };
      iter {
       expr="i++";
      };
     };
     AssignExpr @[3] {
      name="AssignExpr_avglength10nseqinputdatarows";
      desc="compute average sequence length";
      flags=CAN_REVERT_TO_CODE;
      code_string="avg_length = 1.0/n_seq * input_data.rows";
      result_var=.programs.gp[2][0].vars[1]$$;
      expr {
       expr="1.0/n_seq * input_data.rows";
      };
     };
     PrintVar @[4] {
      name="PrintVar_Printavglength";
      desc=;
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="Print  avg_length";
      message=;
      print_var=$.programs.gp[2][0].vars[1]$;
      print_var2=NULL;
      print_var3=NULL;
      print_var4=NULL;
      print_var5=NULL;
      print_var6=NULL;
      debug=0;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2][1].doc$$: };
    };
    name="ReberGenSequence";
    short_nm="RbGSqn";
    tags=;
    desc="Chooses subsequent states based on reber grammar defined by TransitionMatrix";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=DataTable;
     el_def=0;
     DataTable @[0] {
      name="TransitionMatrix";
      desc=;
      data {
       name="data";
       el_typ=float_Data;
       el_def=0;
       float_Data @[0] {
	name="DestNode0";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0;0;	};
       };
       float_Data @[1] {
	name="DestNode1";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0.5;0.5;0;0;0;	};
       };
       float_Data @[2] {
	name="DestNode2";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0.5;0;0.5;0.5;0;	};
       };
       float_Data @[3] {
	name="DestNode3";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0.5;0;0;0.5;	};
       };
       float_Data @[4] {
	name="DestNode4";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0.5;0;0;	};
       };
       float_Data @[5] {
	name="DestNode5";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0.5;0.5;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [5] 0;1;2;3;4;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
     DataTable @[1] {
      name="PathLabels";
      desc="original Reber ambiguous labels";
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       int_Data @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode0LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0;0;	};
       };
       int_Data @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode1LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 1;2;0;0;0;	};
       };
       int_Data @[2] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode2LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 5;0;1;3;0;	};
       };
       int_Data @[3] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode3LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;3;0;0;5;	};
       };
       int_Data @[4] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode4LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;4;0;0;	};
       };
       int_Data @[5] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode5LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;2;4;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [5] 0;1;2;3;4;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
     DataTable @[2] {
      name="PathLabels_unambig";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       int_Data @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode0LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0;0;	};
       };
       int_Data @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode1LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 1;3;0;0;0;	};
       };
       int_Data @[2] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode2LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 2;0;5;7;0;	};
       };
       int_Data @[3] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode3LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;4;0;0;9;	};
       };
       int_Data @[4] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode4LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;6;0;0;	};
       };
       int_Data @[5] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode5LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;8;10;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [5] 0;1;2;3;4;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
     DataTable @[3] {
      name="PathLabels_ambig";
      desc="original Reber ambiguous labels";
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       int_Data @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode0LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0;0;	};
       };
       int_Data @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode1LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 1;2;0;0;0;	};
       };
       int_Data @[2] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode2LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 5;0;1;3;0;	};
       };
       int_Data @[3] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode3LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;3;0;0;5;	};
       };
       int_Data @[4] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode4LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;4;0;0;	};
       };
       int_Data @[5] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode5LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;2;4;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [5] 0;1;2;3;4;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="transition_matrix";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[2][1].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="path_labels";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[2][1].objs[1]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="path_labels_unambig";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[2][1].objs[2]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="path_labels_ambig";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[2][1].objs[3]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="seq_no";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="unit_names";
      var_type=T_Object;
      object_type=taOBase;
      completion_type=;
      object_val=.data.gp[0][3]$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="state";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="previous label; start at \"B\"";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="next_input";
      var_type=T_Int;
      int_val=4;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="next input";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="other_trg";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="other possible target";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="n_state";
      var_type=T_Int;
      int_val=6;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="next label index";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="next_state";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="next label index";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="tot_p";
      var_type=T_Real;
      real_val=1;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="total probability";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="prob";
      var_type=T_Real;
      real_val=1.1;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="total probability";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="state_p";
      var_type=T_Real;
      real_val=0.5;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="total probability";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      name="Comment_initvarsforthesequence";
      desc="init vars for the sequence";
      flags=CAN_REVERT_TO_CODE;
      code_string="// init vars for the sequence";
     };
     AssignExpr @[1] {
      name="AssignExpr_state0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="state = 0";
      result_var=.programs.gp[2][1].vars[1]$$;
      expr {
       expr="0";
      };
     };
     ProgramCall @[2] {
      name="ProgramCall_GenTrialinputdata01stateseqno";
      desc="generate a row of data based on previous pass through";
      flags=CAN_REVERT_TO_CODE;
      code_string="GenTrial(input_data, 0, -1, state, seq_no)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="cur_input";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="0";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="other_trg";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=int;
	type="int";
	name="state";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="state";
	};
       };
       ProgArg @[4] {
	arg_type=int;
	type="int";
	name="seq_no";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="seq_no";
	};
       };
      };
      target=.programs.gp[2][3]$$;
      targ_ld_init="*GenTrial*";
     };
     WhileLoop @[3] {
      name="WhileLoop_whilestate5";
      desc="traverse all the states until it reaches the end";
      flags=CAN_REVERT_TO_CODE;
      code_string="while (state!=5)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_totp00";
	desc="re init this";
	flags=CAN_REVERT_TO_CODE;
	code_string="tot_p = 0.0";
	result_var=.programs.gp[2][1].vars[6]$$;
	expr {
	 expr="0.0";
	};
       };
       AssignExpr @[1] {
	name="AssignExpr_othertrg1";
	desc="re init this";
	flags=CAN_REVERT_TO_CODE;
	code_string="other_trg = -1";
	result_var=.programs.gp[2][1].vars[3]$$;
	expr {
	 expr="-1";
	};
       };
       RandomCall @[2] {
	name="RandomCall_probRandomZeroOne";
	desc="get a random number to determine what target is chosen as output";
	flags=CAN_REVERT_TO_CODE;
	code_string="prob = Random::ZeroOne()";
	result_var=.programs.gp[2][1].vars[7]$$;
	object_type=Random;
	method=Random::ZeroOne;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="thr_no";
	  required=0;
	  def_val="-1";
	  prev_expr=;
	  expr {
	   expr=;
	  };
	 };
	};
       };
       ForLoop @[3] {
	name="ForLoop_fornstate0nstate6nstate";
	desc="loop over columns for the current row (current state)";
	flags=CAN_REVERT_TO_CODE;
	code_string="for (n_state = 0; n_state < 6; n_state++)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_stateptransition_tValnstatestate";
	  desc="get the probability of making this transition";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="state_p = transition_matrix->GetVal(n_state, state)";
	  result_var=.programs.gp[2][1].vars[8]$$;
	  obj=.programs.gp[2][1].objs_vars[0]$$;
	  method=DataTable::GetVal;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_Variant_ref;
	    type="Variant&";
	    name="col";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="n_state";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=int;
	    type="int";
	    name="row";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="state";
	    };
	   };
	  };
	  meth_sig="const_Variant GetVal(Variant& col, int row)";
	  meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
	 };
	 If @[1] {
	  name="If_ifprobstateptotp";
	  desc="if it's in the current range, select it; if not, then dont";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (prob <= (state_p+tot_p))";
	  cond {
	   expr="prob <= (state_p+tot_p)";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_nextinputpathlab_tValnstatestate";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="next_input = path_labels->GetVal(n_state, state)";
	    result_var=.programs.gp[2][1].vars[2]$$;
	    obj=.programs.gp[2][1].objs_vars[1]$$;
	    method=DataTable::GetVal;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=const_Variant_ref;
	      type="Variant&";
	      name="col";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="n_state";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=int;
	      type="int";
	      name="row";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="state";
	      };
	     };
	    };
	    meth_sig="const_Variant GetVal(Variant& col, int row)";
	    meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
	   };
	   AssignExpr @[1] {
	    name="AssignExpr_prob11";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="prob = 1.1";
	    result_var=$.programs.gp[2][1].vars[7]$;
	    expr {
	     expr="1.1";
	    };
	   };
	   AssignExpr @[2] {
	    name="AssignExpr_nextstatenstate";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="next_state = n_state";
	    result_var=.programs.gp[2][1].vars[5]$$;
	    expr {
	     expr="n_state";
	    };
	   };
	  };
	 };
	 Else @[2] {
	  name="Else_If_ifprobstateptotp";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="else";
	  cond {
	   expr=;
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   If @[0] {
	    name="If_ifstatep0";
	    desc="if it's not the selected output, but it's still possible based on the grammar, get the other potential target";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="if (state_p>0)";
	    cond {
	     expr="state_p>0";
	    };
	    true_code {
	     name="true_code";
	     el_typ=ProgCode;
	     el_def=0;
	     MethodCall @[0] {
	      name="MethodCall_othertrgpathlabe_tValnstatestate";
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="other_trg = path_labels->GetVal(n_state, state)";
	      result_var=$.programs.gp[2][1].vars[3]$;
	      obj=$.programs.gp[2][1].objs_vars[1]$;
	      method=DataTable::GetVal;
	      meth_args {
	       name="meth_args";
	       el_typ=ProgArg;
	       el_def=0;
	       ProgArg @[0] {
		arg_type=const_Variant_ref;
		type="Variant&";
		name="col";
		required=1;
		def_val=;
		prev_expr=;
		expr {
		 expr="n_state";
		};
	       };
	       ProgArg @[1] {
		arg_type=int;
		type="int";
		name="row";
		required=1;
		def_val=;
		prev_expr=;
		expr {
		 expr="state";
		};
	       };
	      };
	      meth_sig="const_Variant GetVal(Variant& col, int row)";
	      meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
	     };
	    };
	   };
	  };
	 };
	 VarIncr @[3] {
	  name="VarIncr_totpstatep";
	  desc="increment this so future columns can be selected";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="tot_p += state_p";
	  var=$.programs.gp[2][1].vars[6]$;
	  expr {
	   expr="state_p";
	  };
	 };
	 PrintExpr @[4] {
	  name="PrintExpr_Printstatetnstat_tprobtnextstate";
	  desc=;
	  flags=OFF|CAN_REVERT_TO_CODE;
	  code_string="Print state << \"\\t\" << n_state << \"\\t\" << state_p << \"\\t\" << prob << \"\\t\" << next_state";
	  expr {
	   expr="state << \"\\t\" << n_state << \"\\t\" << state_p << \"\\t\" << prob << \"\\t\" << next_state";
	  };
	  debug=0;
	 };
	};
	init {
	 expr="n_state = 0";
	};
	test {
	 expr="n_state < 6";
	};
	iter {
	 expr="n_state++";
	};
       };
       ProgramCall @[4] {
	name="ProgramCall_GenTrialinputdat_gnextstateseqno";
	desc="generate a row of data based on previous pass through";
	flags=CAN_REVERT_TO_CODE;
	code_string="GenTrial(input_data, next_input, other_trg, next_state, seq_no)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="cur_input";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="next_input";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=int;
	  type="int";
	  name="other_trg";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="other_trg";
	  };
	 };
	 ProgArg @[3] {
	  arg_type=int;
	  type="int";
	  name="state";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="next_state";
	  };
	 };
	 ProgArg @[4] {
	  arg_type=int;
	  type="int";
	  name="seq_no";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="seq_no";
	  };
	 };
	};
	target=$.programs.gp[2][3]$;
	targ_ld_init="*GenTrial*";
       };
       AssignExpr @[5] {
	name="AssignExpr_statenextstate";
	desc="assign the current state to the next state";
	flags=CAN_REVERT_TO_CODE;
	code_string="state = next_state";
	result_var=$.programs.gp[2][1].vars[1]$;
	expr {
	 expr="next_state";
	};
       };
      };
      test {
       expr="state!=5";
      };
     };
     ProgramCall @[4] {
      name="ProgramCall_GenTrialinputdata1415seqno";
      desc="generate the last row of data for the given sequence";
      flags=CAN_REVERT_TO_CODE;
      code_string="GenTrial(input_data, 14, -1, 5, seq_no)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="cur_input";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="14";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="other_trg";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=int;
	type="int";
	name="state";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="5";
	};
       };
       ProgArg @[4] {
	arg_type=int;
	type="int";
	name="seq_no";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="seq_no";
	};
       };
      };
      target=$.programs.gp[2][3]$;
      targ_ld_init="*GenTrial*";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2][2].doc$$: };
    };
    name="RandomGenSequence";
    short_nm="RndGSq";
    tags=;
    desc="Chooses subsequent states randomly (stops when it reaches E; can't go back to B after starting)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=DataTable;
     el_def=0;
     DataTable @[0] {
      name="TransitionMatrix";
      desc=;
      data {
       name="data";
       el_typ=float_Data;
       el_def=0;
       float_Data @[0] {
	name="DestNode0";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0;0;	};
       };
       float_Data @[1] {
	name="DestNode1";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0.5;0.5;0;0;0;	};
       };
       float_Data @[2] {
	name="DestNode2";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0.5;0;0.5;0.5;0;	};
       };
       float_Data @[3] {
	name="DestNode3";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0.5;0;0;0.5;	};
       };
       float_Data @[4] {
	name="DestNode4";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0.5;0;0;	};
       };
       float_Data @[5] {
	name="DestNode5";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=9;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0.5;0.5;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [5] 0;1;2;3;4;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
     DataTable @[1] {
      name="PathLabelInds";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       int_Data @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode0LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;0;0;	};
       };
       int_Data @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode1LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 1;2;0;0;0;	};
       };
       int_Data @[2] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode2LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 5;0;1;3;0;	};
       };
       int_Data @[3] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode3LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;3;0;0;5;	};
       };
       int_Data @[4] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode4LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;4;0;0;	};
       };
       int_Data @[5] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItemBase;
	 el_def=0;
	 UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
	};
	name="ToDestNode5LabelInd";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=19;
	matrix_col_width=10;
	ar {
	 name="ar";
	[5] 0;0;0;2;4;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [5] 0;1;2;3;4;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="transition_matrix";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[2][2].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="path_label_inds";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[2][2].objs[1]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="seq_no";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="unit_names";
      var_type=T_Object;
      object_type=taOBase;
      completion_type=;
      object_val=$.data.gp[0][3]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="state";
      var_type=T_Int;
      int_val=0;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="previous label; start at \"B\"";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="prv_label_ind";
      var_type=T_Int;
      int_val=1;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="previous label; start at \"B\"";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="next_input";
      var_type=T_Int;
      int_val=7;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="next label index";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="other_trg";
      var_type=T_Int;
      int_val=-1;
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="next label index";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      name="Comment_initvarsforthesequence";
      desc="init vars for the sequence";
      flags=CAN_REVERT_TO_CODE;
      code_string="// init vars for the sequence";
     };
     AssignExpr @[1] {
      name="AssignExpr_state0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="state = 0";
      result_var=.programs.gp[2][2].vars[1]$$;
      expr {
       expr="0";
      };
     };
     AssignExpr @[2] {
      name="AssignExpr_nextinput6";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="next_input = 6";
      result_var=.programs.gp[2][2].vars[3]$$;
      expr {
       expr="6";
      };
     };
     AssignExpr @[3] {
      name="AssignExpr_othertrg1";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="other_trg = -1";
      result_var=.programs.gp[2][2].vars[4]$$;
      expr {
       expr="-1";
      };
     };
     WhileLoop @[4] {
      name="WhileLoop_whilenextinput7";
      desc="traverse all the states until it reaches the end";
      flags=CAN_REVERT_TO_CODE;
      code_string="while (next_input != 7)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_prvlabelindnextinput";
	desc="make the current state the next state from the previous iteration";
	flags=CAN_REVERT_TO_CODE;
	code_string="prv_label_ind = next_input";
	result_var=.programs.gp[2][2].vars[2]$$;
	expr {
	 expr="next_input";
	};
       };
       RandomCall @[1] {
	name="RandomCall_nextinputRandomIntMinMax07";
	desc="randomly decide what the next_lab is";
	flags=CAN_REVERT_TO_CODE;
	code_string="next_input = Random::IntMinMax(0, 7, )";
	result_var=$.programs.gp[2][2].vars[3]$;
	object_type=Random;
	method=Random::IntMinMax;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="min";
	  required=1;
	  def_val=;
	  prev_expr="0";
	  expr {
	   expr="0";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="max";
	  required=1;
	  def_val=;
	  prev_expr="7";
	  expr {
	   expr="7";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=int;
	  type="int";
	  name="thr_no";
	  required=0;
	  def_val="-1";
	  prev_expr=;
	  expr {
	   expr=;
	  };
	 };
	};
       };
       ProgramCall @[2] {
	name="ProgramCall_GenTrialinputdat_extinput10seqno";
	desc="generate a row of data based on previous pass through";
	flags=CAN_REVERT_TO_CODE;
	code_string="GenTrial(input_data, next_input, -1, 0, seq_no)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="cur_input";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="next_input";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=int;
	  type="int";
	  name="other_trg";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="-1";
	  };
	 };
	 ProgArg @[3] {
	  arg_type=int;
	  type="int";
	  name="state";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="0";
	  };
	 };
	 ProgArg @[4] {
	  arg_type=int;
	  type="int";
	  name="seq_no";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="seq_no";
	  };
	 };
	};
	target=$.programs.gp[2][3]$;
	targ_ld_init="*GenTrial*";
       };
      };
      test {
       expr="next_input != 7";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2][3].doc$$: };
    };
    name="GenTrial";
    short_nm="GTrl";
    tags=;
    desc="actually adds data to the input table, used for both Reber and Random generation";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     DataTable @[0] {
      name="PathLabels";
      desc=;
      data {
       name="data";
       el_typ=String_Data;
       el_def=0;
       String_Data @[0] {
	name="label";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[15] "B";"T";"S";"X";"V";"P";"C";"D";"F";"G";
"H";"J";"K";"L";"E";	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [15] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="path_labels";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[2][3].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table with the labels of the transitions in them";
      init_from=NULL;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="Input";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="I_B";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="I_T";
	value=1;
	desc=;
       };
       DynEnumItem @[2] {
	name="I_S";
	value=2;
	desc=;
       };
       DynEnumItem @[3] {
	name="I_X";
	value=3;
	desc=;
       };
       DynEnumItem @[4] {
	name="I_V";
	value=4;
	desc=;
       };
       DynEnumItem @[5] {
	name="I_P";
	value=5;
	desc=;
       };
       DynEnumItem @[6] {
	name="I_C";
	value=6;
	desc=;
       };
       DynEnumItem @[7] {
	name="I_D";
	value=7;
	desc=;
       };
       DynEnumItem @[8] {
	name="I_F";
	value=8;
	desc=;
       };
       DynEnumItem @[9] {
	name="I_G";
	value=9;
	desc=;
       };
       DynEnumItem @[10] {
	name="I_H";
	value=10;
	desc=;
       };
       DynEnumItem @[11] {
	name="I_J";
	value=11;
	desc=;
       };
       DynEnumItem @[12] {
	name="I_K";
	value=12;
	desc=;
       };
       DynEnumItem @[13] {
	name="I_L";
	value=13;
	desc=;
       };
       DynEnumItem @[14] {
	name="I_E";
	value=14;
	desc=;
       };
       DynEnumItem @[15] {
	name="N_Inputs";
	value=15;
	desc=;
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="the data table to create";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="cur_input";
      var_type=T_Int;
      int_val=7;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="current input unit active";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="other_trg";
      var_type=T_Int;
      int_val=-1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="other possible target input";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="state";
      var_type=T_Int;
      int_val=5;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="the actual state/node";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="seq_no";
      var_type=T_Int;
      int_val=25;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="label";
      var_type=T_String;
      string_val="E";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current label (either for previous or next transition)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="Name";
      var_type=T_String;
      string_val="S5_E";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of the trial";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="unit_names";
      var_type=T_Object;
      object_type=taOBase;
      completion_type=;
      object_val=$.data.gp[0][3]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      completion_type=;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="Group";
      var_type=T_String;
      string_val="Seq_24";
      completion_type=;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     InitNamedUnits @[0] {
      name="InitNamedUnits_InitNamedUnits";
      desc="sets dyn. enums and unit names in network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Init Named Units";
      input_data_var=.programs.gp[2][3].args[0]$$;
      unit_names_var=.programs.gp[2][3].vars[2]$$;
      network_var=.programs.gp[2][3].vars[3]$$;
      n_lay_name_chars=1;
      max_unit_chars=-1;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     AddNewDataRow @[0] {
      name="AddNewDataRow_AddNewRowtableinputdata";
      desc="add a new data row";
      flags=CAN_REVERT_TO_CODE;
      code_string="Add New Row:  table = input_data ";
      data_var=$.programs.gp[2][3].args[0]$;
     };
     DataVarProg @[1] {
      name="DataVarProg_DataFromtablepat_belvar2var3var4";
      desc="get the previous transitions name";
      flags=CAN_REVERT_TO_CODE;
      code_string="Data From:  table=path_labels  row_spec=row_num  row_var=cur_input  set=from  all_matches=false  var_1=label  var_2=?  var_3=?  var_4=? ";
      data_var=.programs.gp[2][3].objs_vars[0]$$;
      row_spec=ROW_NUM;
      row_var=.programs.gp[2][3].args[1]$$;
      set_data=0;
      all_matches=0;
      quiet=1;
      var_1=.programs.gp[2][3].vars[0]$$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     AssignExpr @[2] {
      name="AssignExpr_NameSstatelabel";
      desc="start building the trial name";
      flags=CAN_REVERT_TO_CODE;
      code_string="Name = \"S\" + state + \"_\" + label";
      result_var=.programs.gp[2][3].vars[1]$$;
      expr {
       expr="\"S\" + state + \"_\" + label";
      };
     };
     CssExpr @[3] {
      name="CssExpr_inputdataInputcurinput0110";
      desc="set the input";
      flags=CAN_REVERT_TO_CODE;
      code_string="input_data[\"Input\"][cur_input,0,-1] = 1.0;";
      expr {
       expr="input_data[\"Input\"][cur_input,0,-1] = 1.0;";
      };
     };
     CssExpr @[4] {
      name="CssExpr_inputdataTargetscurinput0110";
      desc="set the target";
      flags=CAN_REVERT_TO_CODE;
      code_string="input_data[\"Targets\"][cur_input,0,-1] = 1.0;";
      expr {
       expr="input_data[\"Targets\"][cur_input,0,-1] = 1.0;";
      };
     };
     If @[5] {
      name="If_ifothertrg0";
      desc="assign another target if there is one";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (other_trg>=0)";
      cond {
       expr="other_trg>=0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       DataVarProg @[0] {
	name="DataVarProg_DataFromtablepat_belvar2var3var4";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Data From:  table=path_labels  row_spec=row_num  row_var=other_trg  set=from  all_matches=false  var_1=label  var_2=?  var_3=?  var_4=? ";
	data_var=$.programs.gp[2][3].objs_vars[0]$;
	row_spec=ROW_NUM;
	row_var=.programs.gp[2][3].args[2]$$;
	set_data=0;
	all_matches=0;
	quiet=1;
	var_1=$.programs.gp[2][3].vars[0]$;
	var_2=NULL;
	var_3=NULL;
	var_4=NULL;
       };
       CssExpr @[1] {
	name="CssExpr_inputdataTargetsothertrg0110";
	desc="set the other target";
	flags=CAN_REVERT_TO_CODE;
	code_string="input_data[\"Targets\"][other_trg,0,-1] = 1.0;";
	expr {
	 expr="input_data[\"Targets\"][other_trg,0,-1] = 1.0;";
	};
       };
      };
     };
     AssignExpr @[6] {
      name="AssignExpr_GroupSeqseqno";
      desc="assign group name";
      flags=CAN_REVERT_TO_CODE;
      code_string="Group = \"Seq_\" + seq_no";
      result_var=.programs.gp[2][3].vars[4]$$;
      expr {
       expr="\"Seq_\" + seq_no";
      };
     };
     DataVarProg @[7] {
      name="DataVarProg_DataTotableinput_r2Groupvar3var4";
      desc="assign the tiral name";
      flags=CAN_REVERT_TO_CODE;
      code_string="Data To:  table=input_data  row_spec=cur_row  set=to  all_matches=false  var_1=Name  var_2=Group  var_3=?  var_4=? ";
      data_var=$.programs.gp[2][3].args[0]$;
      row_spec=CUR_ROW;
      row_var=NULL;
      set_data=1;
      all_matches=0;
      quiet=1;
      var_1=$.programs.gp[2][3].vars[1]$;
      var_2=$.programs.gp[2][3].vars[4]$;
      var_3=NULL;
      var_4=NULL;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2][4].doc$$: };
    };
    name="SetDefaults";
    short_nm="SDflts";
    tags=;
    desc=;
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="HiddenLayer";
      var_type=T_Object;
      object_type=LeabraLayerSpec;
      completion_type=;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="ConSpec_0";
      var_type=T_Object;
      object_type=LeabraConSpec;
      completion_type=;
      object_val=$.networks[0].specs[1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="ContextLayer";
      var_type=T_Object;
      object_type=taOBase;
      completion_type=;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="hidden_k";
      var_type=T_Int;
      int_val=4;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="lmix_hebb";
      var_type=T_Real;
      real_val=0.02;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="lrate";
      var_type=T_Real;
      real_val=0.01;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[6] {
      name="fm_hid";
      var_type=T_Real;
      real_val=1;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[7] {
      name="fm_prv";
      var_type=T_Real;
      real_val=0;
      completion_type=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[8] {
      name="ControlPanel";
      var_type=T_Object;
      object_type=taOBase;
      completion_type=;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MemberAssign @[0] {
      name="MemberAssign_HiddenLayerkwtak4";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="HiddenLayer.kwta.k = 4";
      obj=.programs.gp[2][4].vars[0]$$;
      path="kwta.k";
      expr {
       expr="4";
      };
      update_after=0;
     };
     MemberAssign @[1] {
      name="MemberAssign_ConSpec0lmixhebb002";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ConSpec_0.lmix.hebb = 0.02";
      obj=.programs.gp[2][4].vars[1]$$;
      path="lmix.hebb";
      expr {
       expr="0.02";
      };
      update_after=0;
     };
     MemberAssign @[2] {
      name="MemberAssign_ConSpec0lrate001";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ConSpec_0.lrate = 0.01";
      obj=$.programs.gp[2][4].vars[1]$;
      path="lrate";
      expr {
       expr="0.01";
      };
      update_after=0;
     };
     MemberAssign @[3] {
      name="MemberAssign_ContextLayerupdtfmhid1";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ContextLayer.updt.fm_hid = 1";
      obj=.programs.gp[2][4].vars[2]$$;
      path="updt.fm_hid";
      expr {
       expr="1";
      };
      update_after=0;
     };
     MemberAssign @[4] {
      name="MemberAssign_ContextLayerupdtfmprv0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ContextLayer.updt.fm_prv = 0";
      obj=$.programs.gp[2][4].vars[2]$;
      path="updt.fm_prv";
      expr {
       expr="0";
      };
      update_after=0;
     };
     MethodCall @[5] {
      name="MethodCall_ControlPanelmethod";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ControlPanel->method()";
      result_var=NULL;
      obj=.programs.gp[2][4].vars[8]$$;
      method=NULL;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig=;
      meth_desc=;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[3] {
   name="Analysis";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][0].doc$$: };
    };
    name="ClusterHidden";
    short_nm="ClsHdd";
    tags=;
    desc=;
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=DataTable;
     el_def=0;
     DataTable @[0] {
      name="clust_data";
      desc=;
      data {
       name="data";
       el_typ=float_Data;
       el_def=0;
       float_Data @[0] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_254";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @[0] {name="X_AXIS": value=1: val_type_fixed=0: };
	 UserDataItem @[1] {name="MAX": value=22.27779006958008: val_type_fixed=0: };
	};
	name="X";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[449] 0;0;0;0;0;4.3216028;4.3216028;7.9159365;7.9159365;10.358417;
7.9159365;7.9159365;7.9159365;7.9159365;10.358417;10.358418;12.729834;12.729834;14.565096;12.729834;
12.729834;12.729834;12.729834;14.565096;14.565096;14.576489;14.565096;14.565096;14.565096;14.565096;
14.576489;14.565096;14.565096;14.565096;12.729834;12.729834;10.358418;10.358417;10.358418;12.729834;
12.729834;14.757818;12.729834;12.729834;12.729834;12.729834;14.757818;14.757818;15.393267;14.757818;
14.757818;14.757818;14.757818;15.393267;14.757818;14.757818;14.757818;12.729834;12.729834;10.358418;
10.358417;7.9159365;7.9159365;4.3216028;4.3216028;4.3216028;7.9159365;7.9159365;11.229115;11.229115;
13.549057;11.229115;11.229115;11.229115;11.229115;13.549057;11.229115;11.229115;11.229115;7.9159365;
7.9159365;7.9159365;11.229115;11.229115;13.935271;13.935271;16.110716;16.110716;16.216614;16.110716;
16.110716;16.110716;16.110716;16.216614;16.216614;16.240238;16.216614;16.216614;16.216614;16.216614;
16.240238;16.216614;16.216614;16.216614;16.110716;16.110716;13.935271;13.935271;13.935271;16.110716;
16.110716;16.820299;16.820299;16.935869;16.820299;16.820299;16.820299;16.820299;16.935869;16.935869;
17.004847;16.935869;16.935869;16.935869;16.935869;17.004847;17.004847;17.023081;17.004847;17.004847;
17.004847;17.004847;17.023081;17.023081;17.02915;17.023081;17.023081;17.023081;17.023081;17.02915;
17.02915;17.031275;17.02915;17.02915;17.02915;17.02915;17.031275;17.02915;17.02915;17.02915;
17.023081;17.023081;17.004847;17.004847;16.935869;16.935869;16.820299;16.820299;16.110716;16.110716;
16.110716;16.820299;16.820299;17.353548;16.820299;16.820299;16.820299;16.820299;17.353548;17.353548;
17.477633;17.353548;17.353548;17.353548;17.353548;17.477633;17.353548;17.353548;17.353548;16.820299;
16.820299;16.110716;16.110716;13.935271;13.935271;11.229115;11.229115;11.229115;13.935271;13.935271;
16.602806;16.602806;18.646782;16.602806;16.602806;16.602806;16.602806;18.646782;18.646782;18.970766;
18.646782;18.646782;18.646782;18.646782;18.970766;18.646782;18.646782;18.646782;16.602806;16.602806;
13.935271;13.935271;13.935271;16.602806;16.602806;18.729883;18.729883;18.73068;18.729883;18.729883;
18.729883;18.729883;18.73068;18.729883;18.729883;18.729883;16.602806;16.602806;16.602806;18.729883;
18.729883;19.068089;18.729883;18.729883;18.729883;18.729883;19.068089;18.729883;18.729883;18.729883;
16.602806;16.602806;13.935271;13.935271;11.229115;11.229115;7.9159365;7.9159365;4.3216028;4.3216028;
0;0;0;4.3216028;4.3216028;8.4363737;8.4363737;8.4785805;8.4363737;8.4363737;
8.4363737;8.4363737;8.4785805;8.4785805;8.4804287;8.4785805;8.4785805;8.4785805;8.4785805;8.4804287;
8.4804287;8.4806213;8.4804287;8.4804287;8.4804287;8.4804287;8.4806213;8.4806213;8.4806213;8.4806213;
8.4806213;8.4806213;8.4806213;8.4806213;8.4806213;8.4806213;8.4806213;8.4804287;8.4804287;8.4785805;
8.4785805;8.4363737;8.4363737;4.3216028;4.3216028;4.3216028;8.4363737;8.4363728;12.29147;12.29147;
14.402655;14.402655;14.403296;14.402655;14.402655;14.402655;14.402655;14.403296;14.402655;14.402655;
14.402655;12.29147;12.29147;12.29147;14.402655;14.402655;14.475153;14.402655;14.402655;14.402655;
14.402655;14.475153;14.475153;14.480197;14.475153;14.475153;14.475153;14.475153;14.480197;14.475153;
14.475153;14.475153;14.402655;14.402655;12.29147;12.29147;8.4363728;8.4363737;8.4363728;12.29147;
12.291471;16.033136;16.033136;18.563602;16.033136;16.033136;16.033136;16.033136;18.563602;18.563602;
18.575012;18.575012;18.57502;18.575012;18.575012;18.575012;18.575012;18.57502;18.575012;18.575012;
18.575012;18.563602;18.563602;18.563602;18.575012;18.575012;18.583965;18.575012;18.575012;18.575012;
18.575012;18.583965;18.575012;18.575012;18.575012;18.563602;18.563602;16.033136;16.033136;12.291471;
12.29147;12.291471;16.033136;16.033136;18.680187;18.680187;18.875696;18.680187;18.680187;18.680187;
18.680187;18.875696;18.875696;18.891703;18.875696;18.875696;18.875696;18.875696;18.891703;18.875696;
18.875696;18.875696;18.680187;18.680187;16.033136;16.033136;16.033136;18.680187;18.680187;19.126789;
18.680187;18.680187;18.680187;18.680187;19.126789;19.126789;19.371853;19.126789;19.126789;19.126789;
19.126789;19.371853;19.371853;19.371992;19.371853;19.371853;19.371853;19.371853;19.371992;19.371853;
19.371853;19.371853;19.126789;19.126789;18.680187;18.680187;16.033136;16.033136;12.291471;12.29147;
8.4363728;8.4363737;4.3216028;4.3216028;0;0;0;0;0;	};
       };
       float_Data @[1] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_255";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @[0] {name="PLOT_1": value=1: val_type_fixed=0: };
	 UserDataItem @[1] {name="MAX": value=49.79999923706055: val_type_fixed=0: };
	 UserDataItem @[2] {name="MIN": value=0.2000000029802322: val_type_fixed=0: };
	};
	name="Y";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[449] 20.968262;20.968262;20.968262;20.968262;7.7412109;7.7412109;2.125;2.125;0.5;0.5;
0.5;0.5;2.125;3.75;3.75;2.25;2.25;1.5;1.5;1.5;
1.5;2.25;3;3;2.5;2.5;2.5;2.5;3;3.5;
3.5;3.5;3.5;3;3;2.25;2.25;3.75;5.25;5.25;
4.5;4.5;4.5;4.5;5.25;6;6;5.5;5.5;5.5;
5.5;6;6.5;6.5;6.5;6.5;6;6;5.25;5.25;
3.75;3.75;2.125;2.125;7.7412109;13.357422;13.357422;8;8;7.5;
7.5;7.5;7.5;8;8.5;8.5;8.5;8.5;8;8;
13.357422;18.714844;18.714844;13.304688;13.304688;10.25;10.25;9.5;9.5;9.5;
9.5;10.25;11;11;10.5;10.5;10.5;10.5;11;11.5;
11.5;11.5;11.5;11;11;10.25;10.25;13.304688;16.359375;16.359375;
13.46875;13.46875;12.5;12.5;12.5;12.5;13.46875;14.4375;14.4375;13.5;
13.5;13.5;13.5;14.4375;15.375;15.375;14.5;14.5;14.5;14.5;
15.375;16.25;16.25;15.5;15.5;15.5;15.5;16.25;17;17;
16.5;16.5;16.5;16.5;17;17.5;17.5;17.5;17.5;17;
17;16.25;16.25;15.375;15.375;14.4375;14.4375;13.46875;13.46875;16.359375;
19.25;19.25;18.5;18.5;18.5;18.5;19.25;20;20;19.5;
19.5;19.5;19.5;20;20.5;20.5;20.5;20.5;20;20;
19.25;19.25;16.359375;16.359375;13.304688;13.304688;18.714844;24.125;24.125;22.25;
22.25;21.5;21.5;21.5;21.5;22.25;23;23;22.5;22.5;
22.5;22.5;23;23.5;23.5;23.5;23.5;23;23;22.25;
22.25;24.125;26;26;25;25;24.5;24.5;24.5;24.5;
25;25.5;25.5;25.5;25.5;25;25;26;27;27;
26.5;26.5;26.5;26.5;27;27.5;27.5;27.5;27.5;27;
27;26;26;24.125;24.125;18.714844;18.714844;13.357422;13.357422;7.7412109;
7.7412109;20.968262;34.195312;34.195312;29.4375;29.4375;28.5;28.5;28.5;28.5;
29.4375;30.375;30.375;29.5;29.5;29.5;29.5;30.375;31.25;31.25;
30.5;30.5;30.5;30.5;31.25;32;32;31.5;31.5;31.5;
31.5;32;32.5;32.5;32.5;32.5;32;32;31.25;31.25;
30.375;30.375;29.4375;29.4375;34.195312;38.953125;38.953125;35.125;35.125;34;
34;33.5;33.5;33.5;33.5;34;34.5;34.5;34.5;34.5;
34;34;35.125;36.25;36.25;35.5;35.5;35.5;35.5;36.25;
37;37;36.5;36.5;36.5;36.5;37;37.5;37.5;37.5;
37.5;37;37;36.25;36.25;35.125;35.125;38.953125;42.78125;42.78125;
39.75;39.75;38.5;38.5;38.5;38.5;39.75;41;41;40;
40;39.5;39.5;39.5;39.5;40;40.5;40.5;40.5;40.5;
40;40;41;42;42;41.5;41.5;41.5;41.5;42;
42.5;42.5;42.5;42.5;42;42;41;41;39.75;39.75;
42.78125;45.8125;45.8125;44.25;44.25;43.5;43.5;43.5;43.5;44.25;
45;45;44.5;44.5;44.5;44.5;45;45.5;45.5;45.5;
45.5;45;45;44.25;44.25;45.8125;47.375;47.375;46.5;46.5;
46.5;46.5;47.375;48.25;48.25;47.5;47.5;47.5;47.5;48.25;
49;49;48.5;48.5;48.5;48.5;49;49.5;49.5;49.5;
49.5;49;49;48.25;48.25;47.375;47.375;45.8125;45.8125;42.78125;
42.78125;38.953125;38.953125;34.195312;34.195312;20.968262;20.968262;20.968262;20.968262;	};
       };
       String_Data @[2] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_256";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @[0] {name="PLOT_2": value=1: val_type_fixed=0: };
	};
	name="Label";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[449] ;;;;;;;;;"S1_S";
;;;;;;;;"S5_S";;
;;;;;"S2_X";;;;;
"S2_X";;;;;;;;;;
;"S3_X";;;;;;;"S2_X";;
;;;"S2_X";;;;;;;
;;;;;;;;;;
"S1_S";;;;;"S3_X";;;;;
;;;;;;;;"S4_V";;
;;;;;"S4_V";;;;;
"S4_V";;;;;;;;;;
;;;"S2_T";;;;;;;
"S2_T";;;;;;;"S2_T";;;
;;;;"S2_T";;;;;;
;"S2_T";;;;;"S2_T";;;;
;;;;;;;;;;
;;;"S2_T";;;;;;;
"S2_T";;;;;"S2_T";;;;;
;;;;;;;;;;
;;"S2_T";;;;;;;"S2_T";
;;;;"S2_T";;;;;;
;;;;;;;"S4_V";;;
;;"S4_V";;;;;;;;
;"S4_V";;;;;"S4_V";;;;
;;;;;;;;;;
;;;;;;;"S0_B";;;
;;;;"S0_B";;;;;;
;"S0_B";;;;;;;"S0_B";;
;;;"S0_B";;;;;;;
;;;;;;;;;;
;;"S1_T";;;;;"S1_T";;;
;;;;;;"S2_P";;;;
;;;"S2_P";;;;;"S2_P";;
;;;;;;;;;;
;;;"S5_E";;;;;;;
;;"S5_E";;;;;"S5_E";;;
;;;;;;"S5_E";;;;
;"S5_E";;;;;;;;;
;;;;;;"S3_P";;;;
;;;"S3_P";;;;;"S3_P";;
;;;;;;;;;"S5_V";
;;;;;;"S5_V";;;;
;;;"S5_V";;;;;"S5_V";;
;;;;;;;;;;
;;;;;;;;;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [449] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;49;
50;51;52;53;54;55;56;57;58;59;
60;61;62;63;64;65;66;67;68;69;
70;71;72;73;74;75;76;77;78;79;
80;81;82;83;84;85;86;87;88;89;
90;91;92;93;94;95;96;97;98;99;
100;101;102;103;104;105;106;107;108;109;
110;111;112;113;114;115;116;117;118;119;
120;121;122;123;124;125;126;127;128;129;
130;131;132;133;134;135;136;137;138;139;
140;141;142;143;144;145;146;147;148;149;
150;151;152;153;154;155;156;157;158;159;
160;161;162;163;164;165;166;167;168;169;
170;171;172;173;174;175;176;177;178;179;
180;181;182;183;184;185;186;187;188;189;
190;191;192;193;194;195;196;197;198;199;
200;201;202;203;204;205;206;207;208;209;
210;211;212;213;214;215;216;217;218;219;
220;221;222;223;224;225;226;227;228;229;
230;231;232;233;234;235;236;237;238;239;
240;241;242;243;244;245;246;247;248;249;
250;251;252;253;254;255;256;257;258;259;
260;261;262;263;264;265;266;267;268;269;
270;271;272;273;274;275;276;277;278;279;
280;281;282;283;284;285;286;287;288;289;
290;291;292;293;294;295;296;297;298;299;
300;301;302;303;304;305;306;307;308;309;
310;311;312;313;314;315;316;317;318;319;
320;321;322;323;324;325;326;327;328;329;
330;331;332;333;334;335;336;337;338;339;
340;341;342;343;344;345;346;347;348;349;
350;351;352;353;354;355;356;357;358;359;
360;361;362;363;364;365;366;367;368;369;
370;371;372;373;374;375;376;377;378;379;
380;381;382;383;384;385;386;387;388;389;
390;391;392;393;394;395;396;397;398;399;
400;401;402;403;404;405;406;407;408;409;
410;411;412;413;414;415;416;417;418;419;
420;421;422;423;424;425;426;427;428;429;
430;431;432;433;434;435;436;437;438;439;
440;441;442;443;444;445;446;447;448;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    objs_vars {
     name="objs_vars";
     el_typ=ProgVar;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="test_data_trial";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=$.data.gp[1][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="clust_data";
      var_type=T_Object;
      object_type=DataTable;
      completion_type=;
      object_val=.programs.gp[3][0].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     DataAnalCall @[0] {
      name="DataAnalCall_taDataAnalCluste_denacttrialname";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="taDataAnal::Cluster(clust_data, 1, test_data_trial, \"Hidden_act\", \"trial_name\", , , )";
      result_var=NULL;
      object_type=taDataAnal;
      method=taDataAnal::Cluster;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="clust_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="clust_data";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="view";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="1";
	};
       };
       ProgArg @[2] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="src_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="test_data_trial";
	};
       };
       ProgArg @[3] {
	arg_type=const_taString_ref;
	type="taString&";
	name="data_col_nm";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\"Hidden_act\"";
	};
       };
       ProgArg @[4] {
	arg_type=const_taString_ref;
	type="taString&";
	name="name_col_nm";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\"trial_name\"";
	};
       };
       ProgArg @[5] {
	arg_type=taMath::DistMetric;
	type="taMath::DistMetric";
	name="metric";
	required=0;
	def_val="taMath::EUCLIDIAN";
	prev_expr=;
	expr {
	 expr=;
	};
       };
       ProgArg @[6] {
	arg_type=bool;
	type="bool";
	name="norm";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr=;
	};
       };
       ProgArg @[7] {
	arg_type=float;
	type="float";
	name="tol";
	required=0;
	def_val="0.0f";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="view_win_lft": value=0.1668865: val_type_fixed=0: };
    UserDataItem @[1] {name="view_win_top": value=0.2235225: val_type_fixed=0: };
    UserDataItem @[2] {name="view_win_wd": value=0.8519129: val_type_fixed=0: };
    UserDataItem @[3] {name="view_win_ht": value=0.8115857: val_type_fixed=0: };
    UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
    UserDataItem @[5] {name="view_splitter_state": value=AAAA/wAAAAEAAAADAAABqQAAA6sAAARkAQAAAAYBAAAAAQE=: val_type_fixed=0: };
   };
   name="Browser3";
   m_data=.$$;
   cur_font_size=12;
   visible=1;
   win_name=".projects[\"fsa_deep_trc\"] - fsa_deep_trc.proj";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   revert_to_tab_no=-1;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_visible": value=1: val_type_fixed=0: };
     };
     name="Application";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @[0] {
     name="Navigator";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.$;
    };
    PanelViewer @[1] {
     name="Editor";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
    };
    T3PanelViewer @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_52";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_frame_selected": value=1: val_type_fixed=0: };
      UserDataItem @[1] {name="view_panel_selected": value=1: val_type_fixed=0: };
     };
     name="Visualizer";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @[0] {
       name="FSA_TI";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=NetView;
	 el_def=0;
	 NetView @[0] {
	  name="FSA_TI_View";
	  m_data=$.networks[0]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  display=1;
	  lay_layout=THREE_D;
	  lay_mv=0;
	  net_text=1;
	  net_state_text {
	   name="net_state_text";
	   state_items {
	    name="state_items";
	    el_typ=NetViewStateItem;
	    el_def=0;
	    NetViewStateItem @[0] {name="batch": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[1] {name="epoch": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[2] {name="group": net_member=1: display=0: width=4: found=1: };
	    NetViewStateItem @[3] {name="trial": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[4] {name="tick": net_member=1: display=0: width=4: found=1: };
	    NetViewStateItem @[5] {name="cycle": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[6] {name="time": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[7] {name="total_trials": net_member=1: display=0: width=6: found=1: };
	    NetViewStateItem @[8] {name="sse": net_member=1: display=1: width=8: found=1: };
	    NetViewStateItem @[9] {name="group_name": net_member=1: display=0: width=12: found=1: };
	    NetViewStateItem @[10] {name="trial_name": net_member=1: display=1: width=12: found=1: };
	    NetViewStateItem @[11] {name="output_name": net_member=1: display=1: width=12: found=1: };
	    NetViewStateItem @[12] {name="quarter": net_member=1: display=1: width=4: found=1: };
	    NetViewStateItem @[13] {name="phase": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[14] {name="tot_cycle": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[15] {name="rt_cycles": net_member=1: display=0: width=4: found=1: };
	    NetViewStateItem @[16] {name="ext_rew": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[17] {name="norm_err": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[18] {name="cos_err": net_member=1: display=0: width=8: found=1: };
	    NetViewStateItem @[19] {name="minus_output_name": net_member=1: display=0: width=12: found=1: };
	   };
	  };
	  show_iconified=0;
	  cur_unit_vals{ act;	  };
	  hot_vars{ targ;ext;act;net;bias_wt;bias_dwt;act_eq;act_m;act_p;act_dif;act_avg;r.wt;r.wt*act;s.wt;r.dwt;s.dwt;deep_ctxt;deep_mod;deep_lrn;avg_l;deep_raw_prv;deep_raw;act_q0;deep_raw_net;	  };
	  unit_src_path=".layers[3][27]";
	  con_type=ANY_CON;
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  movie_size {x=720: y=720: };
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NAMES;
	  max_size {x=18: y=12: z=1.5: };
	  max_size2d {x=15: y=24: z=1: };
	  eff_max_size {x=18: y=12: z=1.5: };
	  font_sizes {net_name=0.05: net_vals=0.05: layer=0.04: layer_min=0.01: layer_vals=0.03: prjn=0.01: unit=0.05: un_nm_len=3: un_val_prec=2: };
	  view_params {xy_square=0: unit_spacing=0.05: prjn_disp=L_R_B: prjn_name=0: prjn_width=0.002: prjn_trans=0.5: lay_trans=0.5: unit_trans=0.6: laygp_width=1: show_laygp=1: };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="scale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs["C_ColdHot"]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name="scale_ranges";
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    var_name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    var_name="net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    var_name="act_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[3] {
	    var_name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[4] {
	    var_name="targ";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[5] {
	    var_name="act_avg";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[6] {
	    var_name="act_p";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[7] {
	    var_name="r.pdw";
	    auto_scale=1;
	    min=-0.001604635;
	    max=0.001604635;
	   };
	   ScaleRange @[8] {
	    var_name="s.pdw";
	    auto_scale=1;
	    min=-0;
	    max=0;
	   };
	   ScaleRange @[9] {
	    var_name="bias.wt";
	    auto_scale=1;
	    min=-0.0095;
	    max=0.0095;
	   };
	   ScaleRange @[10] {
	    var_name="s.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[11] {
	    var_name="act_dif";
	    auto_scale=0;
	    min=-0.1215;
	    max=0.1215;
	   };
	   ScaleRange @[12] {
	    var_name="misc_1";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[13] {
	    var_name="avg_s";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[14] {
	    var_name="avg_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[15] {
	    var_name="ext";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[16] {
	    var_name="p_act_p";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[17] {
	    var_name="act_ctxt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[18] {
	    var_name="net_ctxt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[19] {
	    var_name="davg";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[20] {
	    var_name="act_q0";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[21] {
	    var_name="act_q1";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[22] {
	    var_name="act_q2";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[23] {
	    var_name="act_q3";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[24] {
	    var_name="act_q4";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[25] {
	    var_name="act_eq";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[26] {
	    var_name="ti_ctxt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[27] {
	    var_name="deep_raw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[28] {
	    var_name="deep_ctxt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[29] {
	    var_name="deep_norm";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[30] {
	    var_name="r.dwt";
	    auto_scale=1;
	    min=-0;
	    max=0;
	   };
	   ScaleRange @[31] {
	    var_name="net_prv_q";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[32] {
	    var_name="deep_mod";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[33] {
	    var_name="deep_norm_net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[34] {
	    var_name="bias_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[35] {
	    var_name="deep_raw_norm";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[36] {
	    var_name="deep_lrn";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[37] {
	    var_name="deep_net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[38] {
	    var_name="avg_l";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[39] {
	    var_name="deep_raw_prv";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[40] {
	    var_name="deep_raw_net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=0;InputP=-1;Targets=0;Hidden=-1;Hidden_deep=-1;	  };
	  selected_unit_var=;
	 };
	};
       };
       fix_name=0;
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=0.514: y=0.6686362: z=1.625534: };
	 orient {x=-0.9999787: y=0: z=0: rot=0.07800166: };
	 focal_dist=1.872064;
	};
	T3SavedView @[1] {
	 name="Network";
	 view_saved=1;
	 pos {x=0.5592512: y=0.9531382: z=1.683051: };
	 orient {x=-1: y=0: z=0: rot=0.140001: };
	 focal_dist=2.361696;
	};
	T3SavedView @[2] {
	 name="Graph";
	 view_saved=1;
	 pos {x=1.019273: y=0.750841: z=0.9571444: };
	 orient {x=-0.3202807: y=-0.945003: z=0.06625895: rot=0.4310353: };
	 focal_dist=1.774254;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[1] {
       name="EpochOutputData";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GraphTableView;
	 el_def=0;
	 GraphTableView @[0] {
	  name="EpochOutputData_Graph";
	  m_data=$.data.gp[1][2]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.data.gp[1][2].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.data.gp[1][2].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="avg_sse";
	    m_data=.data.gp[1][2].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1.94068: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="cnt_err";
	    m_data=.data.gp[1][2].data[3]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=138: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="avg_ext_rew";
	    m_data=.data.gp[1][2].data[4]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="avg_cycles";
	    m_data=.data.gp[1][2].data[5]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="epoch_time_tot";
	    m_data=.data.gp[1][2].data[6]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="epoch_time_usr";
	    m_data=.data.gp[1][2].data[7]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="fsa_err_sum";
	    m_data=.data.gp[1][2].data[8]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10000;
	  view_range {min=0: max=120: };
	  page_rows=-9056008;
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=1;
	  point_size=0.01;
	  point_spacing=1;
	  solid_lines=0;
	  show_caption=1;
	  bar_space=0.2;
	  bar_depth=0.01;
	  label_spacing=-1;
	  string_spacing=1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis_label_rot=0;
	  x_axis {
	   name="x_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   col_name_good="epoch";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=32: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  z_axis {
	   name="z_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   col_name_good="batch";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  tot_plots=16;
	  plots {
	   name="plots";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="EpochOutputData_Graph_plot_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="fsa_err_sum";
	    col_name_good="fsa_err_sum";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=54: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="EpochOutputData_Graph_plot_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="avg_sse";
	    col_name_good="avg_sse";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1.94068: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=SQUARE;
	    alt_y=1;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="EpochOutputData_Graph_plot_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="cnt_err";
	    col_name_good="cnt_err";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=50: fix_max=0: max=118: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="EpochOutputData_Graph_plot_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="cnt_err";
	    col_name_good="cnt_err";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=138: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="EpochOutputData_Graph_plot_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="EpochOutputData_Graph_plot_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CROSS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[6] {
	    name="EpochOutputData_Graph_plot_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=STAR;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[7] {
	    name="EpochOutputData_Graph_plot_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[8] {
	    name="EpochOutputData_Graph_plot_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[9] {
	    name="EpochOutputData_Graph_plot_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=SQUARE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[10] {
	    name="EpochOutputData_Graph_plot_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[11] {
	    name="EpochOutputData_Graph_plot_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[12] {
	    name="EpochOutputData_Graph_plot_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[13] {
	    name="EpochOutputData_Graph_plot_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[14] {
	    name="EpochOutputData_Graph_plot_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CROSS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[15] {
	    name="EpochOutputData_Graph_plot_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=STAR;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  errbars {
	   name="errbars";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="EpochOutputData_Graph_err_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="EpochOutputData_Graph_err_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="EpochOutputData_Graph_err_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="EpochOutputData_Graph_err_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="EpochOutputData_Graph_err_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="EpochOutputData_Graph_err_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[6] {
	    name="EpochOutputData_Graph_err_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[7] {
	    name="EpochOutputData_Graph_err_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[8] {
	    name="EpochOutputData_Graph_err_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[9] {
	    name="EpochOutputData_Graph_err_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[10] {
	    name="EpochOutputData_Graph_err_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[11] {
	    name="EpochOutputData_Graph_err_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[12] {
	    name="EpochOutputData_Graph_err_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[13] {
	    name="EpochOutputData_Graph_err_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[14] {
	    name="EpochOutputData_Graph_err_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[15] {
	    name="EpochOutputData_Graph_err_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  x_axis_label=;
	  y_axis_label=;
	  alt_y_axis_label=;
	  z_axis_label=;
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED;
	  color_gp_use_y=0;
	  color_axis {
	   name="color_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="raster_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       fix_name=0;
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.465: y=0.5009999: z=1.523924: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.033924;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[2] {
       name="TrialOutputData";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GraphTableView;
	 el_def=0;
	 GraphTableView @[0] {
	  name="TrialOutputData_Graph";
	  m_data=$.data.gp[1][0]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.data.gp[1][0].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.data.gp[1][0].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="trial";
	    m_data=.data.gp[1][0].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="group";
	    m_data=.data.gp[1][0].data[3]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="trial_name";
	    m_data=.data.gp[1][0].data[4]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="group_name";
	    m_data=.data.gp[1][0].data[5]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="quarter";
	    m_data=.data.gp[1][0].data[6]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="rt_cycles";
	    m_data=.data.gp[1][0].data[7]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="sse";
	    m_data=.data.gp[1][0].data[8]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="ext_rew";
	    m_data=.data.gp[1][0].data[9]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="fsa_err";
	    m_data=.data.gp[1][0].data[10]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10000;
	  view_range {min=0: max=98: };
	  page_rows=-8334087;
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE_AND_POINTS;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=0.01;
	  point_spacing=1;
	  solid_lines=0;
	  show_caption=0;
	  bar_space=0.2;
	  bar_depth=0.01;
	  label_spacing=-1;
	  string_spacing=1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis_label_rot=0;
	  x_axis {
	   name="x_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="trial";
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=15: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  z_axis {
	   name="z_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=1;
	   axis=Z;
	   col_name="group";
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=11: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  tot_plots=16;
	  plots {
	   name="plots";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="TrialOutputData_Graph_plot_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="fsa_err";
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="TrialOutputData_Graph_plot_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="trial_name";
	    col_name_good=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=SQUARE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="TrialOutputData_Graph_plot_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="TrialOutputData_Graph_plot_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="TrialOutputData_Graph_plot_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="TrialOutputData_Graph_plot_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CROSS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[6] {
	    name="TrialOutputData_Graph_plot_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=STAR;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[7] {
	    name="TrialOutputData_Graph_plot_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[8] {
	    name="TrialOutputData_Graph_plot_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[9] {
	    name="TrialOutputData_Graph_plot_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=SQUARE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[10] {
	    name="TrialOutputData_Graph_plot_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[11] {
	    name="TrialOutputData_Graph_plot_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[12] {
	    name="TrialOutputData_Graph_plot_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[13] {
	    name="TrialOutputData_Graph_plot_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[14] {
	    name="TrialOutputData_Graph_plot_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CROSS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[15] {
	    name="TrialOutputData_Graph_plot_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=STAR;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  errbars {
	   name="errbars";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="TrialOutputData_Graph_err_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="TrialOutputData_Graph_err_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="TrialOutputData_Graph_err_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="TrialOutputData_Graph_err_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="TrialOutputData_Graph_err_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="TrialOutputData_Graph_err_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[6] {
	    name="TrialOutputData_Graph_err_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[7] {
	    name="TrialOutputData_Graph_err_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[8] {
	    name="TrialOutputData_Graph_err_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[9] {
	    name="TrialOutputData_Graph_err_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[10] {
	    name="TrialOutputData_Graph_err_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[11] {
	    name="TrialOutputData_Graph_err_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[12] {
	    name="TrialOutputData_Graph_err_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[13] {
	    name="TrialOutputData_Graph_err_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[14] {
	    name="TrialOutputData_Graph_err_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[15] {
	    name="TrialOutputData_Graph_err_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  x_axis_label=;
	  y_axis_label=;
	  alt_y_axis_label=;
	  z_axis_label=;
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED;
	  color_gp_use_y=0;
	  color_axis {
	   name="color_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="raster_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       fix_name=0;
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.521875: y=0.4449999: z=1.455096: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.945096;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[3] {
       name="TrialOutputDataTest";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GridTableView;
	 el_def=0;
	 GridTableView @[0] {
	  name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_TrialOutputDataTest_root_view_children_0";
	  m_data=$.data.gp[1][1]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="batch";
	    m_data=.data.gp[1][1].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=0;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="epoch";
	    m_data=.data.gp[1][1].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="trial";
	    m_data=.data.gp[1][1].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="trial_name";
	    m_data=.data.gp[1][1].data[3]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[4] {
	    name="group_name";
	    m_data=.data.gp[1][1].data[4]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[5] {
	    name="rt_cycles";
	    m_data=.data.gp[1][1].data[5]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[6] {
	    name="sse";
	    m_data=.data.gp[1][1].data[6]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[7] {
	    name="ext_rew";
	    m_data=.data.gp[1][1].data[7]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[8] {
	    name="fsa_err";
	    m_data=.data.gp[1][1].data[8]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[9] {
	    name="Hidden_act";
	    m_data=.data.gp[1][1].data[9]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[10] {
	    name="Input_act";
	    m_data=.data.gp[1][1].data[10]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=15;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[11] {
	    name="Target_act";
	    m_data=.data.gp[1][1].data[11]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=15;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10;
	  view_range {min=0: max=9: };
	  page_rows=10;
	  display_on=1;
	  manip_ctrl_on=1;
	  view_cols=5;
	  page_cols=5;
	  col_range {min=4: max=8: };
	  need_scale_update=0;
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-0.95;
	   max=0.95;
	   last_min=-1;
	   last_max=1;
	   range=0.95;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=1;
	  };
	  scale_per_column=0;
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	  use_custom_paging=0;
	 };
	};
       };
       fix_name=0;
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5174999: z=1.443747: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.453747;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[4] {
       name="TrainInputData";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GridTableView;
	 el_def=0;
	 GridTableView @[0] {
	  name="TrainInputData_Grid";
	  m_data=$.data.gp[0][0]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Group";
	    m_data=.data.gp[0][0].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Name";
	    m_data=.data.gp[0][0].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Input";
	    m_data=.data.gp[0][0].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Targets";
	    m_data=.data.gp[0][0].data[3]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=5;
	  view_range {min=0: max=-1: };
	  page_rows=10;
	  display_on=1;
	  manip_ctrl_on=1;
	  view_cols=5;
	  page_cols=5;
	  col_range {min=0: max=3: };
	  need_scale_update=1;
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  scale_per_column=0;
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	  use_custom_paging=0;
	 };
	 GridTableView @[1] {
	  name="UnitNames_Grid";
	  m_data=$.data.gp[0][3]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=1.13: z=0: }: };
	  children {
	   name="children";
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Input";
	    m_data=.data.gp[0][3].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Output";
	    m_data=.data.gp[0][3].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Targets";
	    m_data=.data.gp[0][3].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    scale_min=2.236922e+8;
	    scale_max=0;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=1.13: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=1;
	  view_range {min=0: max=0: };
	  page_rows=10;
	  display_on=1;
	  manip_ctrl_on=1;
	  view_cols=5;
	  page_cols=5;
	  col_range {min=0: max=2: };
	  need_scale_update=1;
	  width=3.3;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=1;
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  scale_per_column=0;
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.03: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	  use_custom_paging=0;
	 };
	};
       };
       fix_name=0;
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.582118: y=0.7139999: z=1.759859: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.769859;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[5] {
       name="clust_data";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GraphTableView;
	 el_def=0;
	 GraphTableView @[0] {
	  name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0";
	  m_data=$.programs.gp[3][0].objs[0]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="X";
	    m_data=.programs.gp[3][0].objs[0].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="Y";
	    m_data=.programs.gp[3][0].objs[0].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="Label";
	    m_data=.programs.gp[3][0].objs[0].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10000;
	  view_range {min=0: max=448: };
	  page_rows=0;
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=0.01;
	  point_spacing=1;
	  solid_lines=0;
	  show_caption=1;
	  bar_space=0.2;
	  bar_depth=0.01;
	  label_spacing=-1;
	  string_spacing=1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis_label_rot=0;
	  x_axis {
	   name="x_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="X";
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=1: max=22.27779: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  z_axis {
	   name="z_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  tot_plots=16;
	  plots {
	   name="plots";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="Y";
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0.2: fix_max=1: max=49.8: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="Label";
	    col_name_good=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=SQUARE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CROSS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[6] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=STAR;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[7] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[8] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[9] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=SQUARE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[10] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=DIAMOND;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[11] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[12] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[13] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=PLUS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[14] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CROSS;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[15] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_plot_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=STAR;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  errbars {
	   name="errbars";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[1] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[2] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[3] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[4] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[5] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[6] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[7] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[8] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[9] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[10] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[11] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[12] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[13] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[14] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	   GraphPlotView @[15] {
	    name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_clust_data_root_view_children_0_err_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	    axis_label=;
	    alt_axis_label=;
	   };
	  };
	  x_axis_label=;
	  y_axis_label=;
	  alt_y_axis_label=;
	  z_axis_label=;
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED;
	  color_gp_use_y=0;
	  color_axis {
	   name="color_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="raster_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	   axis_label=;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       fix_name=0;
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.453052: y=0.4449999: z=1.653968: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.666468;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_lft": value=0: val_type_fixed=0: };
      UserDataItem @[1] {name="view_win_top": value=0.008191925: val_type_fixed=0: };
      UserDataItem @[2] {name="view_win_wd": value=0.02704486: val_type_fixed=0: };
      UserDataItem @[3] {name="view_win_ht": value=0.7647747: val_type_fixed=0: };
      UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
      UserDataItem @[5] {name="view_visible": value=1: val_type_fixed=0: };
     };
     name="Tools";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc="svn rev: 416015 a few more minor tweaks";
 tree_state{ .;.patches;.docs;.wizards;.ctrl_panels;.active_params;.data;.data.gp[0];.data.gp[1];.data.gp[2];.data.gp[3];.programs;.programs.break_points;.programs.gp[0];.programs.gp[1];.programs.gp[2];.programs.gp[3];.viewers[0];.viewers[0].frames[2];.networks;.networks[0];.networks[0].spec_tables;.networks[0].specs;.networks[0].specs[0];.networks[0].specs[1];.networks[0].specs[1].children[1];.networks[0].param_seqs;.networks[0].layers;.networks[0].layers[0];.networks[0].layers[0].projections;.networks[0].layers[1];.networks[0].layers[1].projections;.networks[0].layers[3];.networks[0].layers[3].projections;.networks[0].layers[3].projections[1];.networks[0].layers[4];.networks[0].layers[4].projections;.networks[0].weights; };
 networks {
  name="networks";
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   name="FSA_TI";
   desc=;
   flags=BUILD_INIT_WTS;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   stats {sse_unit_avg=0: sse_sqrt=0: cnt_err_tol=0: prerr=0: cos_err=1: };
   n_units=174;
   n_cons=12943;
   max_prjns=4;
   specs {
    name="specs";
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="LeabraUnitSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{ deep5b_qtr;cifer;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraUnitSpec;
      el_def=0;
      LeabraUnitSpec @[0] {
       name="InputUnits";
       is_used=1;
       used_status=USED;
       desc=;
       unique{        };
       saved{        };
       children {
	name="children";
	el_typ=LeabraUnitSpec;
	el_def=0;
       };
       bias_spec {type=LeabraBiasSpec: spec=.networks[0].specs[1].children[0]$$: };
       act_range {min=0: max=1: range=1: scale=1: };
       sse_tol=0.5;
       act_fun=NOISY_XX1;
       act {thr=0.5: gain=100: nvar=0.005: avg_correct=1: vm_act_thr=0.01: sig_mult=0.33: sig_mult_pow=0.8: sig_gain=3: interp_range=0.01: gain_cor_range=10: gain_cor=0.1: sig_gain_nvar=600: sig_mult_eff=0.1895352: sig_val_at_0=0.09476762: interp_val=0.3843991: };
       act_misc {rec_nd=1: avg_nd=1: dif_avg=0: net_gain=1: avg_trace=0: lambda=0: avg_tau=200: avg_init=0.15: avg_dt=0.005: };
       spike {rise=0: decay=5: g_gain=9: window=3: act_max_hz=200: int_tau=5: int_dt=0.2: };
       spike_misc {ex=0: exp_slope=0: spk_thr=0.5: vm_r=0.3: t_r=3: clamp_max_p=0.12: clamp_type=REGULAR: eff_spk_thr=0.5: };
       opt_thresh {send=0.1: delta=0.005: };
       clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
       vm_range {min=0: max=2: range=2: scale=0.5: };
       init {v_m=0.4: act=0: netin=0: };
       dt {integ=1: vm_tau=3.3: net_tau=1.4: vm_cyc=1: fast_cyc=0: vm_dt=0.3030303: vm_dt_cyc=0.3030303: net_dt=0.7142857: };
       act_avg {ss_tau=2: s_tau=2: m_tau=10: ru_lrn_m=0.1: su_lrn_m=0.1: ss_dt=0.5: s_dt=0.5: m_dt=0.1: ru_lrn_s=0.9: su_lrn_s=0.9: };
       avg_l {init=0.4: gain=1.5: min=0.2: tau=10: lrn_max=0.5: lrn_min=0.0001: lay_act_thr=0.01: dt=0.1: lrn_fact=0.3845385: };
       avg_l_mod {mod=LAY_ERR_MOD: lay_mod_min=0.01: net_mod_min=0.5: net_err_start=0.5: net_err_end=1: };
       g_bar {e=1: l=0.1: i=1: k=1: };
       e_rev {e=1: l=0.3: i=0.25: k=0.1: };
       kna_adapt {on=0: rate_rise=0.8: f_on=1: f_rise=0.05: f_max=0.1: f_tau=50: m_on=1: m_rise=0.02: m_max=0.1: m_tau=200: s_on=1: s_rise=0.001: s_max=1: s_tau=1000: f_dt=0.02: m_dt=0.005: s_dt=0.001: };
       kna_misc {clamp=0: invert_nd=0: max_gc=0.2: max_adapt=0.5: no_targ=1: };
       stp {on=0: algorithm=CYCLES: f_r_ratio=0.02: rec_tau=200: p0=0.1: p0_norm=0.2: kre_tau=100: kre=0.002: fac_tau=4: fac=0.3: thresh=0.5: n_trials=1: rec_prob=0.1: rec_dt=0.005: fac_dt=0.25: kre_dt=0.01: oneo_p0_norm=5: };
       syn_delay {on=0: delay=4: };
       deep_raw_qtr=Q4;
       deep {on=1: role=SUPER: raw_thr_rel=0.1: raw_thr_abs=0.1: mod_min=1: mod_thr=0.1: ctxt_prv=0: tick_updt=-1: else_prv=0.9: mod_range=0: ctxt_new=1: else_new=0.1: };
       trc {p_only_m=0: thal_gate=0: binarize=0: bin_thr=0.4: bin_on=0.3: bin_off=0: };
       da_mod {on=0: mod_gain=0: minus=0: plus=0.1: da_neg_gain=0.1: da_pos_gain=0.1: };
       noise_type {type=NO_NOISE: trial_fixed=1: };
       noise {name="noise": type=GAUSSIAN: mean=0: var=0.001: par=1: };
      };
      LeabraUnitSpec @[1] {
       name="DeepUnits";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ send_deep_mod;deep_norm;deep;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraUnitSpec;
	el_def=0;
       };
       bias_spec {type=LeabraBiasSpec: spec=$.networks[0].specs[1].children[0]$: };
       act_range {min=0: max=1: range=1: scale=1: };
       sse_tol=0.5;
       act_fun=NOISY_XX1;
       act {thr=0.5: gain=100: nvar=0.005: avg_correct=1: vm_act_thr=0.01: sig_mult=0.33: sig_mult_pow=0.8: sig_gain=3: interp_range=0.01: gain_cor_range=10: gain_cor=0.1: sig_gain_nvar=600: sig_mult_eff=0.1895352: sig_val_at_0=0.09476762: interp_val=0.3843991: };
       act_misc {rec_nd=1: avg_nd=1: dif_avg=0: net_gain=1: avg_trace=0: lambda=0: avg_tau=200: avg_init=0.15: avg_dt=0.005: };
       spike {rise=0: decay=5: g_gain=9: window=3: act_max_hz=200: int_tau=5: int_dt=0.2: };
       spike_misc {ex=0: exp_slope=0: spk_thr=0.5: vm_r=0.3: t_r=3: clamp_max_p=0.12: clamp_type=REGULAR: eff_spk_thr=0.5: };
       opt_thresh {send=0.1: delta=0.005: };
       clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
       vm_range {min=0: max=2: range=2: scale=0.5: };
       init {v_m=0.4: act=0: netin=0: };
       dt {integ=1: vm_tau=3.3: net_tau=1.4: vm_cyc=1: fast_cyc=0: vm_dt=0.3030303: vm_dt_cyc=0.3030303: net_dt=0.7142857: };
       act_avg {ss_tau=2: s_tau=2: m_tau=10: ru_lrn_m=0.1: su_lrn_m=0.1: ss_dt=0.5: s_dt=0.5: m_dt=0.1: ru_lrn_s=0.9: su_lrn_s=0.9: };
       avg_l {init=0.4: gain=1.5: min=0.2: tau=10: lrn_max=0.5: lrn_min=0.0001: lay_act_thr=0.01: dt=0.1: lrn_fact=0.3845385: };
       avg_l_mod {mod=LAY_ERR_MOD: lay_mod_min=0.01: net_mod_min=0.5: net_err_start=0.5: net_err_end=1: };
       g_bar {e=1: l=0.1: i=1: k=1: };
       e_rev {e=1: l=0.3: i=0.25: k=0.1: };
       kna_adapt {on=0: rate_rise=0.8: f_on=1: f_rise=0.05: f_max=0.1: f_tau=50: m_on=1: m_rise=0.02: m_max=0.1: m_tau=200: s_on=1: s_rise=0.001: s_max=1: s_tau=1000: f_dt=0.02: m_dt=0.005: s_dt=0.001: };
       kna_misc {clamp=0: invert_nd=0: max_gc=0.2: max_adapt=0.5: no_targ=1: };
       stp {on=0: algorithm=CYCLES: f_r_ratio=0.02: rec_tau=200: p0=0.1: p0_norm=0.2: kre_tau=100: kre=0.002: fac_tau=4: fac=0.3: thresh=0.5: n_trials=1: rec_prob=0.1: rec_dt=0.005: fac_dt=0.25: kre_dt=0.01: oneo_p0_norm=5: };
       syn_delay {on=0: delay=4: };
       deep_raw_qtr=Q4;
       deep {on=1: role=DEEP: raw_thr_rel=0.1: raw_thr_abs=0.1: mod_min=0.7: mod_thr=0.1: ctxt_prv=0: tick_updt=-1: else_prv=0.9: mod_range=0.3: ctxt_new=1: else_new=0.1: };
       trc {p_only_m=0: thal_gate=0: binarize=0: bin_thr=0.4: bin_on=0.3: bin_off=0: };
       da_mod {on=0: mod_gain=0: minus=0: plus=0.1: da_neg_gain=0.1: da_pos_gain=0.1: };
       noise_type {type=NO_NOISE: trial_fixed=1: };
       noise {name="noise": type=GAUSSIAN: mean=0: var=0.001: par=1: };
      };
      LeabraUnitSpec @[2] {
       name="TRCUnits";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ send_deep_mod;deep_norm;deep;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraUnitSpec;
	el_def=0;
       };
       bias_spec {type=LeabraBiasSpec: spec=$.networks[0].specs[1].children[0]$: };
       act_range {min=0: max=1: range=1: scale=1: };
       sse_tol=0.5;
       act_fun=NOISY_XX1;
       act {thr=0.5: gain=100: nvar=0.005: avg_correct=1: vm_act_thr=0.01: sig_mult=0.33: sig_mult_pow=0.8: sig_gain=3: interp_range=0.01: gain_cor_range=10: gain_cor=0.1: sig_gain_nvar=600: sig_mult_eff=0.1895352: sig_val_at_0=0.09476762: interp_val=0.3843991: };
       act_misc {rec_nd=1: avg_nd=1: dif_avg=0: net_gain=1: avg_trace=0: lambda=0: avg_tau=200: avg_init=0.15: avg_dt=0.005: };
       spike {rise=0: decay=5: g_gain=9: window=3: act_max_hz=200: int_tau=5: int_dt=0.2: };
       spike_misc {ex=0: exp_slope=0: spk_thr=0.5: vm_r=0.3: t_r=3: clamp_max_p=0.12: clamp_type=REGULAR: eff_spk_thr=0.5: };
       opt_thresh {send=0.1: delta=0.005: };
       clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
       vm_range {min=0: max=2: range=2: scale=0.5: };
       init {v_m=0.4: act=0: netin=0: };
       dt {integ=1: vm_tau=3.3: net_tau=1.4: vm_cyc=1: fast_cyc=0: vm_dt=0.3030303: vm_dt_cyc=0.3030303: net_dt=0.7142857: };
       act_avg {ss_tau=2: s_tau=2: m_tau=10: ru_lrn_m=0.1: su_lrn_m=0.1: ss_dt=0.5: s_dt=0.5: m_dt=0.1: ru_lrn_s=0.9: su_lrn_s=0.9: };
       avg_l {init=0.4: gain=1.5: min=0.2: tau=10: lrn_max=0.5: lrn_min=0.0001: lay_act_thr=0.01: dt=0.1: lrn_fact=0.3845385: };
       avg_l_mod {mod=LAY_ERR_MOD: lay_mod_min=0.01: net_mod_min=0.5: net_err_start=0.5: net_err_end=1: };
       g_bar {e=1: l=0.1: i=1: k=1: };
       e_rev {e=1: l=0.3: i=0.25: k=0.1: };
       kna_adapt {on=0: rate_rise=0.8: f_on=1: f_rise=0.05: f_max=0.1: f_tau=50: m_on=1: m_rise=0.02: m_max=0.1: m_tau=200: s_on=1: s_rise=0.001: s_max=1: s_tau=1000: f_dt=0.02: m_dt=0.005: s_dt=0.001: };
       kna_misc {clamp=0: invert_nd=0: max_gc=0.2: max_adapt=0.5: no_targ=1: };
       stp {on=0: algorithm=CYCLES: f_r_ratio=0.02: rec_tau=200: p0=0.1: p0_norm=0.2: kre_tau=100: kre=0.002: fac_tau=4: fac=0.3: thresh=0.5: n_trials=1: rec_prob=0.1: rec_dt=0.005: fac_dt=0.25: kre_dt=0.01: oneo_p0_norm=5: };
       syn_delay {on=0: delay=4: };
       deep_raw_qtr=Q4;
       deep {on=1: role=TRC: raw_thr_rel=0.1: raw_thr_abs=0.1: mod_min=0.7: mod_thr=0.1: ctxt_prv=0: tick_updt=-1: else_prv=0.9: mod_range=0.3: ctxt_new=1: else_new=0.1: };
       trc {p_only_m=0: thal_gate=0: binarize=0: bin_thr=0.4: bin_on=0.3: bin_off=0: };
       da_mod {on=0: mod_gain=0: minus=0: plus=0.1: da_neg_gain=0.1: da_pos_gain=0.1: };
       noise_type {type=NO_NOISE: trial_fixed=1: };
       noise {name="noise": type=GAUSSIAN: mean=0: var=0.001: par=1: };
      };
     };
     bias_spec {type=LeabraBiasSpec: spec=$.networks[0].specs[1].children[0]$: };
     act_range {min=0: max=1: range=1: scale=1: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {thr=0.5: gain=100: nvar=0.005: avg_correct=1: vm_act_thr=0.01: sig_mult=0.33: sig_mult_pow=0.8: sig_gain=3: interp_range=0.01: gain_cor_range=10: gain_cor=0.1: sig_gain_nvar=600: sig_mult_eff=0.1895352: sig_val_at_0=0.09476762: interp_val=0.3843991: };
     act_misc {rec_nd=1: avg_nd=1: dif_avg=0: net_gain=1: avg_trace=0: lambda=0: avg_tau=200: avg_init=0.15: avg_dt=0.005: };
     spike {rise=0: decay=5: g_gain=9: window=3: act_max_hz=200: int_tau=5: int_dt=0.2: };
     spike_misc {ex=0: exp_slope=0: spk_thr=0.5: vm_r=0.3: t_r=3: clamp_max_p=0.12: clamp_type=REGULAR: eff_spk_thr=0.5: };
     opt_thresh {send=0.1: delta=0.005: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=2: range=2: scale=0.5: };
     init {v_m=0.4: act=0: netin=0: };
     dt {integ=1: vm_tau=3.3: net_tau=1.4: vm_cyc=1: fast_cyc=0: vm_dt=0.3030303: vm_dt_cyc=0.3030303: net_dt=0.7142857: };
     act_avg {ss_tau=2: s_tau=2: m_tau=10: ru_lrn_m=0.1: su_lrn_m=0.1: ss_dt=0.5: s_dt=0.5: m_dt=0.1: ru_lrn_s=0.9: su_lrn_s=0.9: };
     avg_l {init=0.4: gain=1.5: min=0.2: tau=10: lrn_max=0.5: lrn_min=0.0001: lay_act_thr=0.01: dt=0.1: lrn_fact=0.3845385: };
     avg_l_mod {mod=LAY_ERR_MOD: lay_mod_min=0.01: net_mod_min=0.5: net_err_start=0.5: net_err_end=1: };
     g_bar {e=1: l=0.1: i=1: k=1: };
     e_rev {e=1: l=0.3: i=0.25: k=0.1: };
     kna_adapt {on=0: rate_rise=0.8: f_on=1: f_rise=0.05: f_max=0.1: f_tau=50: m_on=1: m_rise=0.02: m_max=0.1: m_tau=200: s_on=1: s_rise=0.001: s_max=1: s_tau=1000: f_dt=0.02: m_dt=0.005: s_dt=0.001: };
     kna_misc {clamp=0: invert_nd=0: max_gc=0.2: max_adapt=0.5: no_targ=1: };
     stp {on=0: algorithm=CYCLES: f_r_ratio=0.02: rec_tau=200: p0=0.1: p0_norm=0.2: kre_tau=100: kre=0.002: fac_tau=4: fac=0.3: thresh=0.5: n_trials=1: rec_prob=0.1: rec_dt=0.005: fac_dt=0.25: kre_dt=0.01: oneo_p0_norm=5: };
     syn_delay {on=0: delay=4: };
     deep_raw_qtr=Q4;
     deep {on=1: role=SUPER: raw_thr_rel=0.1: raw_thr_abs=0.1: mod_min=1: mod_thr=0.1: ctxt_prv=0: tick_updt=-1: else_prv=0.9: mod_range=0: ctxt_new=1: else_new=0.1: };
     trc {p_only_m=0: thal_gate=0: binarize=0: bin_thr=0.4: bin_on=0.3: bin_off=0: };
     da_mod {on=0: mod_gain=0: minus=0: plus=0.1: da_neg_gain=0.1: da_pos_gain=0.1: };
     noise_type {type=NO_NOISE: trial_fixed=1: };
     noise {name="noise": type=GAUSSIAN: mean=0: var=0.001: par=1: };
    };
    LeabraConSpec @[1] {
     name="LeabraConSpec_0";
     is_used=1;
     used_status=PARENT_USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="BiasSpec_0";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ rnd;wt_scale;wt_scale_init;learn;wt_limits;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
       dwt_thresh=0.1;
      };
      DeepCtxtConSpec @[1] {
       name="LeabraTICtxt";
       is_used=0;
       used_status=CHILD_USED;
       desc=;
       unique{ wt_scale;ti_learn_pred;learn;lmix;delta_dwt;wt_bal;       };
       saved{        };
       children {
	name="children";
	el_typ=DeepCtxtConSpec;
	el_def=0;
	DeepCtxtConSpec @[0] {
	 name="SupToDeepCtxt";
	 is_used=1;
	 used_status=USED;
	 desc=;
	 unique{ wt_scale;ti_learn_pred;learn;lmix;	 };
	 saved{ 	 };
	 children {
	  name="children";
	  el_typ=DeepCtxtConSpec;
	  el_def=0;
	 };
	 rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
	 wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
	 inhib=0;
	 feedback=0;
	 wt_scale {abs=1: rel=1: no_plus_net=0: };
	 learn=1;
	 learn_qtr=Q4;
	 lrate=0.04;
	 cur_lrate=0.04;
	 lrs_mult=1;
	 use_unlearnable=1;
	 rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
	 xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
	 wt_sig {gain=6: off=1: soft_bound=1: };
	 dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
	 momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
	 wt_bal {on=0: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
	 adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
	 slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
	 deep {on=0: bg_lrate=1: fg_lrate=0: };
	 margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
	 dwt_share {on=0: neigh=8: p_share=0.05: };
	 use_lrate_sched=1;
	 lrate_sched {
	  name="lrate_sched";
	  el_typ=SchedItem;
	  el_def=0;
	  default_val=1;
	  interpolate=0;
	 };
	 delta_dwt=0;
	};
	DeepCtxtConSpec @[1] {
	 name="DeepToDeepCtxt";
	 is_used=1;
	 used_status=USED;
	 desc=;
	 unique{ wt_scale;	 };
	 saved{ 	 };
	 children {
	  name="children";
	  el_typ=DeepCtxtConSpec;
	  el_def=0;
	 };
	 rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
	 wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
	 inhib=0;
	 feedback=0;
	 wt_scale {abs=1: rel=1: no_plus_net=0: };
	 learn=1;
	 learn_qtr=Q4;
	 lrate=0.04;
	 cur_lrate=0.04;
	 lrs_mult=1;
	 use_unlearnable=1;
	 rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
	 xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
	 wt_sig {gain=6: off=1: soft_bound=1: };
	 dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
	 momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
	 wt_bal {on=0: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
	 adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
	 slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
	 deep {on=0: bg_lrate=1: fg_lrate=0: };
	 margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
	 dwt_share {on=0: neigh=8: p_share=0.05: };
	 use_lrate_sched=1;
	 lrate_sched {
	  name="lrate_sched";
	  el_typ=SchedItem;
	  el_def=0;
	  default_val=1;
	  interpolate=0;
	 };
	 delta_dwt=0;
	};
	DeepCtxtConSpec @[2] {
	 name="TRCToDeepCtxt";
	 is_used=1;
	 used_status=USED;
	 desc=;
	 unique{ wt_scale;ti_learn_pred;learn;lmix;	 };
	 saved{ 	 };
	 children {
	  name="children";
	  el_typ=DeepCtxtConSpec;
	  el_def=0;
	 };
	 rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
	 wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
	 inhib=0;
	 feedback=0;
	 wt_scale {abs=1: rel=1: no_plus_net=0: };
	 learn=1;
	 learn_qtr=Q4;
	 lrate=0.04;
	 cur_lrate=0.04;
	 lrs_mult=1;
	 use_unlearnable=1;
	 rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
	 xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
	 wt_sig {gain=6: off=1: soft_bound=1: };
	 dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
	 momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
	 wt_bal {on=0: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
	 adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
	 slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
	 deep {on=0: bg_lrate=1: fg_lrate=0: };
	 margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
	 dwt_share {on=0: neigh=8: p_share=0.05: };
	 use_lrate_sched=1;
	 lrate_sched {
	  name="lrate_sched";
	  el_typ=SchedItem;
	  el_def=0;
	  default_val=1;
	  interpolate=0;
	 };
	 delta_dwt=0;
	};
       };
       rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=0: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
       delta_dwt=0;
      };
      SendDeepRawConSpec @[2] {
       name="InputToTRC";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ learn;rnd;wt_limits;       };
       saved{        };
       children {
	name="children";
	el_typ=SendDeepRawConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.8: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
      };
      LeabraConSpec @[3] {
       name="FmTRC";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ wt_scale;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=0.2: no_plus_net=0: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
      };
      LeabraConSpec @[4] {
       name="DeepFmTRC";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ wt_scale;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=0.05: no_plus_net=0: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
      };
      SendDeepModConSpec @[5] {
       name="SendDeepMod";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ learn;rnd;wt_limits;       };
       saved{        };
       children {
	name="children";
	el_typ=SendDeepModConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.8: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
      };
      LeabraConSpec @[6] {
       name="HidFmInput";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ wt_scale;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
      };
      LeabraConSpec @[7] {
       name="HidFmDeep";
       is_used=0;
       used_status=UNUSED;
       desc=;
       unique{ wt_scale;       };
       saved{        };
       children {
	name="children";
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
       inhib=0;
       feedback=0;
       wt_scale {abs=1: rel=0: no_plus_net=0: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       cur_lrate=0.04;
       lrs_mult=1;
       use_unlearnable=1;
       rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
       momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
       wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
       dwt_share {on=0: neigh=8: p_share=0.05: };
       use_lrate_sched=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     feedback=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.04;
     cur_lrate=0.04;
     lrs_mult=1;
     use_unlearnable=1;
     rule {rule=XCAL_CHL: errule=XCAL: bcmrule=SRS: cp_gain=0.8: };
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: thr_p_min=0.001: lrn_thr=0.01: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1: soft_bound=1: };
     dwt_norm {on=1: level=SEND_CONS: decay_tau=1000: norm_min=0.001: lr_comp=0.15: stats=0: decay_dt=0.001: decay_dt_c=0.999: };
     momentum {on=1: m_tau=10: lr_comp=0.1: m_dt=0.1: m_dt_c=0.9: };
     wt_bal {on=1: avg_thr=0.25: hi_thr=0.4: hi_gain=4: lo_thr=0.4: lo_gain=6: act_thr=0.25: act_gain=0: no_targ=1: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_lrn=0.5: };
     dwt_share {on=0: neigh=8: p_share=0.05: };
     use_lrate_sched=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
     };
    };
    LeabraLayerSpec @[2] {
     name="Input";
     is_used=1;
     used_status=USED;
     desc=;
     unique{ kwta;unit_gp_inhib;inhib_misc;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     lay_inhib {on=1: gi=2.2: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=2: ff=1: fb=0.5: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     lay_gp_inhib {on=0: gi=2: ff=1: fb=0.5: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.1: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.5: avg=0: avg_gain=0.2: };
     decay {trial=0: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
    };
    LeabraLayerSpec @[3] {
     name="HiddenLayer";
     is_used=1;
     used_status=USED;
     desc=;
     unique{ unit_gp_inhib;inhib_misc;     };
     saved{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     lay_inhib {on=1: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=2: ff=1: fb=0.5: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     lay_gp_inhib {on=0: gi=2: ff=1: fb=0.5: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.2: fixed=0: use_ext_act=0: use_first=1: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
     decay {trial=0: };
     del_inhib {on=0: prv_trl=0.1: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {pre_hog_thr=0.2: hog_thr=0.3: dead_thr=0.01: };
    };
    FullPrjnSpec @[4] {
     name="FullPrjnSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     saved{      };
     children {
      name="children";
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     set_scale=0;
     init_wt_val=1;
     add_rnd_var=0;
     renorm_wts {on=0: mult_norm=1: avg_wt=0.5: };
    };
    OneToOnePrjnSpec @[5] {
     name="OneToOnePrjn";
     is_used=1;
     used_status=USED;
     desc=;
     unique{ self_con;     };
     saved{      };
     children {
      name="children";
      el_typ=OneToOnePrjnSpec;
      el_def=0;
     };
     self_con=1;
     init_wts=0;
     set_scale=0;
     init_wt_val=1;
     add_rnd_var=0;
     renorm_wts {on=0: mult_norm=1: avg_wt=0.5: };
     n_conns=-1;
     recv_start=0;
     send_start=0;
     use_gp=0;
    };
   };
   param_seqs {
    name="param_seqs";
    el_typ=ParamSeq;
    el_def=0;
   };
   monitor {
    name="monitor";
    items {
     name="items";
     el_typ=NetMonItem;
     el_def=0;
     ignore_sig=0;
    };
    network=$.networks[0]$;
    data=.networks[0].mon_data$$;
    rmv_orphan_cols=1;
   };
   mon_data {
    name="mon_data";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   layers {
    name="layers";
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    pos2d {x=0: y=0: };
    max_disp_size {x=18: y=12: z=2: };
    max_disp_size2d {x=15: y=24: };
    LeabraLayer @[0] {
     name="Input";
     n_recv_prjns=0;
     n_send_prjns=3;
     un_geom_x=15;
     un_geom_y=1;
     un_geom_n=15;
     gp_geom_x=1;
     gp_geom_y=1;
     gp_geom_n=1;
     flat_geom_x=15;
     flat_geom_y=1;
     flat_geom_n=15;
     gp_spc_x=0;
     gp_spc_y=0;
     flags=SAVE_UNIT_NAMES;
     layer_type=INPUT;
     desc=;
     pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=0: y=0: z=0: };
     pos_abs {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     pos2d_abs {x=0: y=0: };
     disp_scale=1;
     un_geom {x=15: y=1: n_not_xy=0: n=15: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=15: y=1: n_not_xy=0: n=15: };
     disp_geom {x=15: y=1: n_not_xy=0: n=15: };
     scaled_disp_geom {x=15: y=1: n_not_xy=0: n=15: };
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_List @. = [0] = LeabraPrjn .networks[0].layers[3].projections[0];
      Projection_List @. = [1] = LeabraPrjn .networks[0].layers[1].projections[0];
      Projection_List @. = [2] = LeabraPrjn .networks[0].layers[4].projections[2];
     };
     unit_spec {type=LeabraUnitSpec: spec=.networks[0].specs[0].children[0]$$: };
     dist {fm_input=0: fm_output=-1: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name="unit_names";
     [15 1] "B";"T";"S";"X";"V";"P";"E";;;;
;;;;;     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=.networks[0].specs[2]$$: };
     adapt_gi=1;
     mod_avg_l_lrn=0;
     acts_m_avg=0.1;
     acts_p_avg=0.1;
     acts_p_avg_eff=0.1;
    };
    LeabraLayer @[1] {
     name="InputP";
     n_recv_prjns=2;
     n_send_prjns=2;
     un_geom_x=15;
     un_geom_y=1;
     un_geom_n=15;
     gp_geom_x=1;
     gp_geom_y=1;
     gp_geom_n=1;
     flat_geom_x=15;
     flat_geom_y=1;
     flat_geom_n=15;
     gp_spc_x=0;
     gp_spc_y=0;
     flags=SAVE_UNIT_NAMES;
     layer_type=HIDDEN;
     desc=;
     pos_rel {rel=BEHIND: other=$.networks[0].layers[0]$: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=0: y=3: z=0: };
     pos_abs {x=0: y=3: z=0: };
     pos2d {x=0: y=3: };
     pos2d_abs {x=0: y=3: };
     disp_scale=1;
     un_geom {x=15: y=1: n_not_xy=0: n=15: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=15: y=1: n_not_xy=0: n=15: };
     disp_geom {x=15: y=1: n_not_xy=0: n=15: };
     scaled_disp_geom {x=15: y=1: n_not_xy=0: n=15: };
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Deep_Raw_Fm_Input";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=$.networks[0].layers[0]$;
       spec {type=OneToOnePrjnSpec: spec=.networks[0].specs[5]$$: };
       con_type=LeabraCon;
       con_spec {type=SendDeepRawConSpec: spec=.networks[0].specs[1].children[2]$$: };
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
      LeabraPrjn @[1] {
       name="Fm_Hidden_deep";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=.networks[0].layers[4]$$;
       spec {type=FullPrjnSpec: spec=.networks[0].specs[4]$$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=$.networks[0].specs[1]$: };
       dir_fixed=0;
       direction=LATERAL;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_List @. = [0] = LeabraPrjn .networks[0].layers[3].projections[1];
      Projection_List @. = [1] = LeabraPrjn .networks[0].layers[4].projections[3];
     };
     unit_spec {type=LeabraUnitSpec: spec=.networks[0].specs[0].children[2]$$: };
     dist {fm_input=1: fm_output=-1: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name="unit_names";
     [15 1] "B";"T";"S";"X";"V";"P";"E";;;;
;;;;;     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.networks[0].specs[2]$: };
     adapt_gi=1;
     mod_avg_l_lrn=0;
     acts_m_avg=0.1;
     acts_p_avg=0.1;
     acts_p_avg_eff=0.1;
    };
    LeabraLayer @[2] {
     name="Targets";
     n_recv_prjns=0;
     n_send_prjns=0;
     un_geom_x=15;
     un_geom_y=1;
     un_geom_n=15;
     gp_geom_x=1;
     gp_geom_y=1;
     gp_geom_n=1;
     flat_geom_x=15;
     flat_geom_y=1;
     flat_geom_n=15;
     gp_spc_x=0;
     gp_spc_y=0;
     flags=SAVE_UNIT_NAMES;
     layer_type=INPUT;
     desc=;
     pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=0: y=6: z=0: };
     pos_abs {x=0: y=6: z=0: };
     pos2d {x=0: y=3: };
     pos2d_abs {x=0: y=3: };
     disp_scale=1;
     un_geom {x=15: y=1: n_not_xy=0: n=15: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=15: y=1: n_not_xy=0: n=15: };
     disp_geom {x=15: y=1: n_not_xy=0: n=15: };
     scaled_disp_geom {x=15: y=1: n_not_xy=0: n=15: };
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
     };
     unit_spec {type=LeabraUnitSpec: spec=.networks[0].specs[0]$$: };
     dist {fm_input=0: fm_output=-1: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name="unit_names";
     [15 1] "B";"T";"S";"X";"V";"P";"E";;;;
;;;;;     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.networks[0].specs[2]$: };
     adapt_gi=1;
     mod_avg_l_lrn=0;
     acts_m_avg=0.1;
     acts_p_avg=0.1;
     acts_p_avg_eff=0.1;
    };
    LeabraLayer @[3] {
     name="Hidden";
     n_recv_prjns=2;
     n_send_prjns=1;
     un_geom_x=8;
     un_geom_y=8;
     un_geom_n=64;
     gp_geom_x=1;
     gp_geom_y=1;
     gp_geom_n=1;
     flat_geom_x=8;
     flat_geom_y=8;
     flat_geom_n=64;
     gp_spc_x=0;
     gp_spc_y=0;
     flags=0;
     layer_type=HIDDEN;
     desc=;
     pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=0: y=4: z=1: };
     pos_abs {x=0: y=4: z=1: };
     pos2d {x=0: y=6: };
     pos2d_abs {x=0: y=6: };
     disp_scale=1;
     un_geom {x=8: y=8: n_not_xy=0: n=64: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=8: y=8: n_not_xy=0: n=64: };
     disp_geom {x=8: y=8: n_not_xy=0: n=64: };
     scaled_disp_geom {x=8: y=8: n_not_xy=0: n=64: };
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=$.networks[0].layers[0]$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[4]$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=.networks[0].specs[1].children[6]$$: };
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
      LeabraPrjn @[1] {
       name="Fm_InputP";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=.networks[0].layers[1]$$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[4]$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=.networks[0].specs[1].children[3]$$: };
       dir_fixed=0;
       direction=LATERAL;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_List @. = [0] = LeabraPrjn .networks[0].layers[4].projections[0];
     };
     unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[0]$: };
     dist {fm_input=1: fm_output=-1: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=.networks[0].specs[3]$$: };
     adapt_gi=1;
     mod_avg_l_lrn=0;
     acts_m_avg=0.2;
     acts_p_avg=0.2;
     acts_p_avg_eff=0.2;
    };
    LeabraLayer @[4] {
     name="Hidden_deep";
     n_recv_prjns=4;
     n_send_prjns=2;
     un_geom_x=8;
     un_geom_y=8;
     un_geom_n=64;
     gp_geom_x=1;
     gp_geom_y=1;
     gp_geom_n=1;
     flat_geom_x=8;
     flat_geom_y=8;
     flat_geom_n=64;
     gp_spc_x=0;
     gp_spc_y=0;
     flags=0;
     layer_type=HIDDEN;
     desc=;
     pos_rel {rel=ABS_POS: other=NULL: x_align=LEFT: x_off=0: y_align=FRONT: y_off=0: space=2: };
     pos {x=10: y=4: z=1: };
     pos_abs {x=10: y=4: z=1: };
     pos2d {x=0: y=16: };
     pos2d_abs {x=0: y=16: };
     disp_scale=1;
     un_geom {x=8: y=8: n_not_xy=0: n=64: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=8: y=8: n_not_xy=0: n=64: };
     disp_geom {x=8: y=8: n_not_xy=0: n=64: };
     scaled_disp_geom {x=8: y=8: n_not_xy=0: n=64: };
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Ctxt_Fm_Hidden";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=$.networks[0].layers[3]$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[4]$: };
       con_type=LeabraCon;
       con_spec {type=DeepCtxtConSpec: spec=.networks[0].specs[1].children[1].children[0]$$: };
       dir_fixed=0;
       direction=LATERAL;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
      LeabraPrjn @[1] {
       name="Ctxt_Fm_Hidden_deep";
       off=0;
       disp=1;
       notes=;
       from_type=SELF;
       from=$.networks[0].layers[4]$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[4]$: };
       con_type=LeabraCon;
       con_spec {type=DeepCtxtConSpec: spec=.networks[0].specs[1].children[1].children[1]$$: };
       dir_fixed=0;
       direction=LATERAL;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
      LeabraPrjn @[2] {
       name="Ctxt_Fm_Input";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=$.networks[0].layers[0]$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[4]$: };
       con_type=LeabraCon;
       con_spec {type=DeepCtxtConSpec: spec=.networks[0].specs[1].children[1].children[2]$$: };
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
      LeabraPrjn @[3] {
       name="Fm_InputP";
       off=0;
       disp=1;
       notes=;
       from_type=CUSTOM;
       from=$.networks[0].layers[1]$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[4]$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=.networks[0].specs[1].children[4]$$: };
       dir_fixed=0;
       direction=LATERAL;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_List @. = [0] = LeabraPrjn .networks[0].layers[1].projections[1];
      Projection_List @. = [1] = LeabraPrjn .networks[0].layers[4].projections[1];
     };
     unit_spec {type=LeabraUnitSpec: spec=.networks[0].specs[0].children[1]$$: };
     dist {fm_input=1: fm_output=-1: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.networks[0].specs[3]$: };
     adapt_gi=1;
     mod_avg_l_lrn=0;
     acts_m_avg=0.2;
     acts_p_avg=0.2;
     acts_p_avg_eff=0.2;
    };
   };
   weights {
    name="weights";
    el_typ=Weights;
    el_def=0;
   };
   auto_build=AUTO_BUILD;
   auto_load_wts=NO_AUTO_LOAD;
   auto_load_file=;
   brain_atlas_name=;
   cuda {sync_units=0: sync_cons=0: min_threads=32: max_threads=1024: cons_per_thread=2: timers_on=0: n_threads=32: };
   wt_save_fmt=TEXT;
   max_disp_size {x=18: y=12: z=2: };
   max_disp_size2d {x=15: y=24: };
   times {quarter=25: deep_cyc=5: time_inc=0.001: wt_bal_int=10: minus=75: plus=25: total_cycles=100: thal_gate_cycle=-2: };
   lstats {trg_max_act_crit=0.5: off_errs=1: on_errs=1: agg_unlearnable=0: wt_bal=0: };
   net_misc {spike=0: deep=0: bias_learn=0: trial_decay=0: diff_scale_p=0: diff_scale_q1=0: wt_bal=1: lay_gp_inhib=0: inhib_cons=0: };
   deep {on=1: ctxt=1: raw_net=1: mod_net=0: raw_qtr=Q4: };
   rel_netin {on=1: trl_skip=10: epc_skip=10: };
  };
 };
};
